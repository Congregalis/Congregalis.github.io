<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Congregalis</title>
  
  
  <link href="https://congregalis.github.io/atom.xml" rel="self"/>
  
  <link href="https://congregalis.github.io/"/>
  <updated>2021-11-14T12:59:28.652Z</updated>
  <id>https://congregalis.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫框架优化——url去重</title>
    <link href="https://congregalis.github.io/2021/11/14/%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94url%E5%8E%BB%E9%87%8D/"/>
    <id>https://congregalis.github.io/2021/11/14/%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94url%E5%8E%BB%E9%87%8D/</id>
    <published>2021-11-14T12:50:48.000Z</published>
    <updated>2021-11-14T12:59:28.652Z</updated>
    
    <content type="html"><![CDATA[<p>在上文的结果截图中可以看出存在重复的爬取结果，而且如果允许链接有重复，那很可能造成一个闭环，这显然不是我们想要的，因此我们对其进行一个去重。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><p>之前的实现中，只是简单把符合条件的 url 加入到待爬取列表中，并未实现去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getNewSeeds</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>    List&lt;String&gt; links = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Elements elements = page.getDocument().select(<span class="hljs-string">&quot;a&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>        String nextUrl = !element.baseUri().equals(<span class="hljs-string">&quot;&quot;</span>) ? element.attr(<span class="hljs-string">&quot;abs:href&quot;</span>) : element.attr(<span class="hljs-string">&quot;href&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!nextUrl.equals(<span class="hljs-string">&quot;&quot;</span>)) links.add(nextUrl);<br>    &#125;<br>    page.setNextSeeds(links);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Set-去重"><a href="#Set-去重" class="headerlink" title="Set 去重"></a>Set 去重</h3><p>第一种优化，直接使用 set 来存所有已经爬过的 url 防止重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于去重，但这样耗费内存极大</span><br><span class="hljs-keyword">private</span> Set&lt;String&gt; linkSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getNewSeeds</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>    List&lt;String&gt; links = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Elements elements = page.getDocument().select(<span class="hljs-string">&quot;a&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>        String nextUrl = !element.baseUri().equals(<span class="hljs-string">&quot;&quot;</span>) ? element.attr(<span class="hljs-string">&quot;abs:href&quot;</span>) : element.attr(<span class="hljs-string">&quot;href&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!nextUrl.equals(<span class="hljs-string">&quot;&quot;</span>) &amp;&amp; linkSet.add(nextUrl)) links.add(nextUrl);<br>    &#125;<br>    page.setNextSeeds(links);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样由于 url 占的空间不小，成千上万条 url 存在 set 里会导致<strong>内存空间的巨大浪费</strong>。</p><h3 id="Set-MD5-去重"><a href="#Set-MD5-去重" class="headerlink" title="Set + MD5 去重"></a>Set + MD5 去重</h3><p>第二种优化，使用 set + md5 加密的方法缩小占用内存。</p><p>创建一个 Md5Util 类，负责对链接进行 md5 加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> core.util;<br><br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.security.MessageDigest;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Md5Util</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Md5Util md5Util = <span class="hljs-keyword">new</span> Md5Util();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Md5Util</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Md5Util <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> md5Util;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            MessageDigest md = MessageDigest.getInstance(<span class="hljs-string">&quot;md5&quot;</span>);<br>            <span class="hljs-keyword">byte</span>[] md5 = md.digest(data.getBytes(StandardCharsets.UTF_8));<br><br>            <span class="hljs-comment">// 将字节数据转换为十六进制</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : md5) &#123;<br>                sb.append(Integer.toHexString(b &amp; <span class="hljs-number">0xff</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>set 中只存加密后的字符串，这样就减少了内存消耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>    String nextUrl = !element.baseUri().equals(<span class="hljs-string">&quot;&quot;</span>) ? element.attr(<span class="hljs-string">&quot;abs:href&quot;</span>) : element.attr(<span class="hljs-string">&quot;href&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!nextUrl.equals(<span class="hljs-string">&quot;&quot;</span>) &amp;&amp; linkSet.add(Md5Util.getInstance().md5(nextUrl)))<br>        links.add(nextUrl);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>使用<strong>位图</strong>（bitmap），或者<strong>布隆过滤器</strong>（boomfilter）可以进一步将空间的占用缩小到极致。但这里限于笔者的水平与其复杂程度，暂不展开讲，有兴趣的读者可以去自行搜索了解。</p><p>后续如果有时间会来完善这一块内容。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>debug 进入看一下第一次爬取的处理过程中拿到的 url 列表如下图所示（seed 为我的博客主页）：<br><img src="/img/tiny-crawler/url_set.jpg"></p><p>可以看出没有重复的链接了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，我们完成了 url 去重这个简单的小功能，且考虑到了多种优化方式，最终项目里决定采用 Set + MD5 的方式来去重。如果还有其他更好的优化方式也欢迎你<a href="http://localhost:4000/about/#%E6%83%B3%E5%92%8C%E6%88%91%E8%AF%B4%E4%BB%80%E4%B9%88">联系我</a>。</p><p>欢迎有兴趣的小伙伴来共同完善这个项目<a href="https://github.com/Congregalis/tiny-crawler">tiny-crawler</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上文的结果截图中可以看出存在重复的爬取结果，而且如果允许链接有重复，那很可能造成一个闭环，这显然不是我们想要的，因此我们对其进行一个去重。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现</summary>
      
    
    
    
    <category term="小项目" scheme="https://congregalis.github.io/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://congregalis.github.io/tags/Java/"/>
    
    <category term="爬虫" scheme="https://congregalis.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>使用docker搭建nextcloud私人网盘</title>
    <link href="https://congregalis.github.io/2021/11/13/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAnextcloud%E7%A7%81%E4%BA%BA%E7%BD%91%E7%9B%98/"/>
    <id>https://congregalis.github.io/2021/11/13/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAnextcloud%E7%A7%81%E4%BA%BA%E7%BD%91%E7%9B%98/</id>
    <published>2021-11-13T06:29:57.000Z</published>
    <updated>2021-11-13T06:42:34.193Z</updated>
    
    <content type="html"><![CDATA[<p>近来买了一台服务器，想搭建一个私人网盘，方便一些资料的传输与存储，于是就看上了 <a href="https://nextcloud.com/">nextcloud</a>。但是直接搭建似乎还要费心于网站环境的搭建以及一系列繁琐的配置。</p><p>自然地就想到了使用 docker 来帮助搭建。<span id="more"></span>docker 可以自动地将应用程序部署为可在云端或者本地运行的可移植的<strong>容器</strong>。这就相当于在服务器里有一个虚拟机，这个虚拟机专门的运行我们的应用程序（如这里的 nextcloud），并且所有环境都在 这个虚拟机中，与外界互不干扰。</p><p>更方便的是网上有许多镜像供我们使用，不需要去理会环境的搭建和配置，拉取镜像后就自动有了环境。这么轻松就可以搭建服务，那就来看看是怎么做的吧。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本次搭建在 Ubuntu 18.04 LTS 下进行，并已安装好 docker。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-拉取-docker-镜像"><a href="#1-拉取-docker-镜像" class="headerlink" title="1.拉取 docker 镜像"></a>1.拉取 docker 镜像</h3><p>为了避免出现一些不好解决的错误，这里拉取特定版本的 mysql 和 nextcloud</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull mysql:<span class="hljs-number">5</span><br><span class="hljs-attribute">docker</span> pull nextcloud:<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h3 id="2-mysql-容器的创建与使用"><a href="#2-mysql-容器的创建与使用" class="headerlink" title="2. mysql 容器的创建与使用"></a>2. mysql 容器的创建与使用</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> <span class="hljs-attribute">--name</span>=nextcloud_db -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=123456789 -d -p 3307:3306 <span class="hljs-attribute">--restart</span>=always mysql:5<br></code></pre></td></tr></table></figure><p>其中 <code>--name</code> 代表容器名，MYSQL_ROOT_PASSWORD 设置容器中 mysql 的密码，自己随意设置即可， <code>-p</code> 自然代表端口号，这里的 <code>3307:3306</code> 代表容器内 mysql 端口号为 3306 而映射到容器外本机占用的端口号为 3307。<code>--restart=always</code> 是指定容器的重启策略，这里设置总是重启， <code>mysql:5</code> 即为上面安装的镜像。</p><p>然后我们需要进入数据库，为 nextcloud 建立一个 database。<br>以下命令进入容器中的数据库：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> nextcloud_db mysql -u root -p<br></code></pre></td></tr></table></figure><p>然后建立 database：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">CREATE DATABASE nextcloud;<br><span class="hljs-keyword">exit</span>;<br></code></pre></td></tr></table></figure><h3 id="3-nextcloud-容器的创建与使用"><a href="#3-nextcloud-容器的创建与使用" class="headerlink" title="3. nextcloud 容器的创建与使用"></a>3. nextcloud 容器的创建与使用</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d --name=nextcloud --link nextcloud_db:db -v <span class="hljs-regexp">/data/</span>nextcloud:<span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>data -p <span class="hljs-number">81</span>:<span class="hljs-number">80</span> --restart=always nextcloud:<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p>其中 <code>--name</code> 代表容器名， <code>--link</code> 很重要，代表与上面第二部中创建的数据库容器相关联，<code>nextcloud_db:db</code> 中前者就是 mysql 容器的容器名，而后者是映射到 nextcloud 里的名字，会在之后的配置中使用到。<code>-p</code>、<code>--restart=always</code>、<code>mysql:5</code> 同上。</p><h3 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h3><p>上面的步骤做完后就已经将两个容器打开了，直接浏览器访问对应的端口号（我这里是81，如同我配置的那样）。即可进入初始配置页面，主要进行管理员账号的创建以及数据库的配置。</p><p><strong>数据目录</strong>就是第三步命令中 <code>-v</code> 后冒号后面的参数，即容器中的<strong>存储目录</strong>，配置数据库就按照自己的数据库信息来写，注意填写数据库地址时，<strong>主机名称</strong>是第三步中映射到 nextcloud 的数据库名（这里就是 db），且<strong>端口号</strong>是第二步中<strong>容器中</strong>使用的数据库端口号，可以理解为这两个容器连接到了一起，所以不从外部（即本机）访问这个数据库。<br><img src="/img/nextcloud/config.jpg" alt="浏览器访问时配置"></p><p>配置完之后稍等片刻，你的私人网盘就搭建完成了！</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>你可以使用我搭好的看一下网盘的效果。</p><p>地址：<a href="http://101.35.202.174:81/">http://101.35.202.174:81/</a></p><p>用户名：public</p><p>密码：publictest</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>docker 的出现大大简化了我们搭建服务的操作，网上有的许多镜像开箱即用，十分方便。我们使用了两个镜像就快速的搭建出了一个私人网盘，妙！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近来买了一台服务器，想搭建一个私人网盘，方便一些资料的传输与存储，于是就看上了 &lt;a href=&quot;https://nextcloud.com/&quot;&gt;nextcloud&lt;/a&gt;。但是直接搭建似乎还要费心于网站环境的搭建以及一系列繁琐的配置。&lt;/p&gt;
&lt;p&gt;自然地就想到了使用 docker 来帮助搭建。</summary>
    
    
    
    <category term="搭建系列" scheme="https://congregalis.github.io/categories/%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="docker" scheme="https://congregalis.github.io/tags/docker/"/>
    
    <category term="nextcloud" scheme="https://congregalis.github.io/tags/nextcloud/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简单的爬虫框架——下载篇</title>
    <link href="https://congregalis.github.io/2021/11/06/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E4%B8%8B%E8%BD%BD%E7%AF%87/"/>
    <id>https://congregalis.github.io/2021/11/06/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E4%B8%8B%E8%BD%BD%E7%AF%87/</id>
    <published>2021-11-06T09:31:50.000Z</published>
    <updated>2021-11-13T06:42:30.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在上文中我们设计好了一个简单的爬虫框架，并为每个模块都提供了一个实现类，除了 Downloader。所以这一章里我们来研究一下 Downloader 的实现，如何去网络上下载得到一个页面所需要的 html。其实也就是像我们日常浏览器做的事，我们输入网址，浏览器给我们返回一个 html 页面，我们要实现的就是这个功能。Apache HttpComponents 下的 HttpClient 工具包为我们实现了很好的基础，它支持 HTTP 最新的版本和建议，所以本文我们就使用这个工具包来完成我们的 Dowanloader。</p><p>本文介绍完后就实现了一个最最简陋的爬虫框架，可以在 <a href="https://github.com/Congregalis/tiny-crawler">tiny-crawler</a> 中 tag 切换到 <strong>0.1.0</strong> 查看这个版本。</p><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>本文基于 <strong>HttpClient4.5.13</strong>，也是目前 maven 仓库被使用最多的一个版本。<br><img src="/img/tiny-crawler/HttpClient.png"></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载十分简单，对应 pom.xml 文件加入相应依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- jsoup--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jsoup<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsoup<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 以下为新加入 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- httpclient --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们新建一个 HttpUtil 类来负责所有的要访问 HTTP 服务的功能。</p><p>HttpClient 的使用其实也不难，具体步骤如下：</p><ol><li><p>创建 httpClient 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CloseableHttpClient httpClient = HttpClients.createDefault();<br></code></pre></td></tr></table></figure></li><li><p>创建要访问的地址对象（因为 httpClient 接收 URI 对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// url 待爬取页面的链接</span><br>URIBuilder uriBuilder = <span class="hljs-keyword">new</span> URIBuilder(url);<br>URI uri = uriBuilder.build();<br></code></pre></td></tr></table></figure></li><li><p>创建 http 对象，这里使用 HttpGet，因为我们爬虫大多数发送的是 get 请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpGet httpGet = <span class="hljs-keyword">new</span> HttpGet(uri);<br></code></pre></td></tr></table></figure></li><li><p>做一些自定义的设置，这里的设置十分多，可以自己参照 api 根据需要去设置，这里只是简单示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CONNECT_TIMEOUT 连接超时时间，单位毫秒</span><br><span class="hljs-comment">// SOCKET_TIMEOUT 请求获取数据的超时时间，单位毫秒</span><br><span class="hljs-comment">// 以上常量自行设置</span><br>RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(CONNECT_TIMEOUT).setSocketTimeout(SOCKET_TIMEOUT).build();<br>httpGet.setConfig(requestConfig);<br></code></pre></td></tr></table></figure></li><li><p>创建 httpResponse 对象并获取响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">CloseableHttpResponse httpResponse = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 执行请求并获得响应结果</span><br>    httpResponse = httpClient.execute(httpGet);<br>    <span class="hljs-comment">// 获取返回结果</span><br>    <span class="hljs-keyword">if</span> (httpResponse != <span class="hljs-keyword">null</span> &amp;&amp; httpResponse.getStatusLine() != <span class="hljs-keyword">null</span>) &#123;<br>        String content = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (httpResponse.getEntity() != <span class="hljs-keyword">null</span>) &#123;<br>            content = EntityUtils.toString(httpResponse.getEntity(), ENCODING);<br>            System.out.println(content);<br>        &#125;<br><br>    &#125;<br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">if</span> (httpResponse != <span class="hljs-keyword">null</span>) httpResponse.close();<br>    <span class="hljs-keyword">if</span> (httpClient != <span class="hljs-keyword">null</span>) httpClient.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>至此就是 HttpClient 最简单最基础的步骤了，最终会得到的 content 即要爬取页面的 html 文档，这个我们可以再交由 Jsoup 去解析，这个就是 Processor 要做的事了。</p><h2 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h2><p>做好了 HttpClient 之后，实现 Downloader 就简单了。Downloader 的任务就是根据链接获取 html ，然后传给 Page 就行了，所以我们这里做一个 Downloader 的实现类，调用一下刚刚实现的 HttpClient 的方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClientDownloader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Downloader</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Page <span class="hljs-title">download</span><span class="hljs-params">(String url)</span> </span>&#123;<br>        String html = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            html = HttpUtil.getInstance().doGet(url);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Page(url, html);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="整合所有步骤"><a href="#整合所有步骤" class="headerlink" title="整合所有步骤"></a>整合所有步骤</h2><p>至此，我们的所有模块都定义并实现完毕，是时候把这些东西都串起来看一看效果了！新建一个 Crawler 类作为启动类，就开始我们的表演吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Crawler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Scheduler scheduler;<br>    <span class="hljs-keyword">private</span> Downloader downloader;<br>    <span class="hljs-keyword">private</span> Processor processor;<br>    <span class="hljs-keyword">private</span> Saver saver;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> threadNum = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> ThreadPoolExecutor poolExecutor;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Crawler</span><span class="hljs-params">()</span> </span>&#123;<br>        init();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Crawler <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Crawler();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        thread(threadNum);<br><br>        <span class="hljs-keyword">if</span> (scheduler == <span class="hljs-keyword">null</span>) scheduler = <span class="hljs-keyword">new</span> QueueScheduler();<br>        <span class="hljs-keyword">if</span> (downloader == <span class="hljs-keyword">null</span>) downloader = <span class="hljs-keyword">new</span> HttpClientDownloader();<br>        <span class="hljs-keyword">if</span> (processor == <span class="hljs-keyword">null</span>) processor = <span class="hljs-keyword">new</span> SimpleTextProcessor();<br>        <span class="hljs-keyword">if</span> (saver == <span class="hljs-keyword">null</span>) saver = <span class="hljs-keyword">new</span> ConsoleSaver();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Crawler <span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> thread(num, <span class="hljs-number">1500L</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Crawler <span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">long</span> keepAliveTime)</span> </span>&#123;<br>        threadNum = num;<br><br>        poolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(threadNum, threadNum, keepAliveTime, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Crawler <span class="hljs-title">setScheduler</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.scheduler = scheduler;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Crawler <span class="hljs-title">setDownloader</span><span class="hljs-params">(Downloader downloader)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.downloader = downloader;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Crawler <span class="hljs-title">setProcessor</span><span class="hljs-params">(Processor processor)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.processor = processor;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Crawler <span class="hljs-title">setSaver</span><span class="hljs-params">(Saver saver)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.saver = saver;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Crawler <span class="hljs-title">addSeed</span><span class="hljs-params">(String url)</span> </span>&#123;<br>        scheduler.offer(url);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            String seed = scheduler.poll();<br>            <span class="hljs-keyword">if</span> (seed == <span class="hljs-keyword">null</span> &amp;&amp; poolExecutor.getActiveCount() == <span class="hljs-number">0</span>) &#123;<br>                poolExecutor.shutdown();<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (seed == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                poolExecutor.execute(() -&gt; &#123;<br>                    Page currPage = downloader.download(seed);<br>                    processor.process(currPage);<br>                    currPage.getNextSeeds().forEach(url -&gt; scheduler.offer(url));<br>                    saver.save(currPage);<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用建造者模式，方便这个类可以链式地调用，因为我们需要设置很多组件进去。同时为了多线程使用，我们开了一个线程池 <code>ThreadPoolExecutor</code>，它的好处是自定义程度比较高，可以设定 keepalive 时间、自定义阻塞队列等。这里我们都先用最简单的来做。</p><p>我们在 <code>run</code> 方法中逐一实现在上文设计篇中所设计的步骤，其实逻辑很简单。</p><p>新建一个测试类，来测试我们的爬虫吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String seed = <span class="hljs-string">&quot;https://baike.baidu.com/item/%E5%BA%95%E7%89%B9%E5%BE%8B/1660180#hotspotmining&quot;</span>;<br>        Crawler.build().addSeed(seed).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到运行很成功，并且支持多线程，速度很快。<br><img src="/img/tiny-crawler/simple_example.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此我们实现了一个最简单基础的爬虫框架，并且让它成功跑起来了。但是当然地，这其中还存在许多的问题，比如上面截图中你会发现存在重复的链接访问，我们当然不希望这样，而且我们这里做的 HttpClientUtil 过于简单，可能还需要对应不同网站要求加一些设置如请求头等。除此之外，我们可能还想要过滤掉我们不想访问的域名，总不能无休止地爬下去，这之后还做的事情还有很多。所以这个爬虫框架的实现还远没有结束，接下来我们会对哪些地方需要优化，又该如何去优化去做深入的探究。</p><p>项目地址：<a href="https://github.com/Congregalis/tiny-crawler">tiny-crawler</a> （tag 切换到 <strong>0.1.0</strong> 查看本文版本）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在上文中我们设计好了一个简单的爬虫框架，并为每个模块都提供了一个实现类，除了 Downloader。所以这一章里我们来研究一下 Downlo</summary>
      
    
    
    
    <category term="小项目" scheme="https://congregalis.github.io/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://congregalis.github.io/tags/Java/"/>
    
    <category term="爬虫" scheme="https://congregalis.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简单的爬虫框架——设计篇</title>
    <link href="https://congregalis.github.io/2021/11/05/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E7%AF%87/"/>
    <id>https://congregalis.github.io/2021/11/05/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E7%AF%87/</id>
    <published>2021-11-05T14:25:02.000Z</published>
    <updated>2021-11-06T17:26:17.741Z</updated>
    
    <content type="html"><![CDATA[<p>主要目的是<strong>学习各种开源爬虫框架的实现原理</strong>并且造一个小轮子，其中会参考许多项目的思想如 <a href="http://webmagic.io/">WebMagic</a> 等。这里只追求最简单的逻辑与最小的代码量实现一个<strong>够用</strong>的爬虫，并且会尽可能地遵循设计原则与使用设计模式。另，本文基于 Java 语言。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一个爬虫最核心的逻辑就是去某个网页上摘取整个 HTML 页面，并通过一定的手段解析想要的内容再加以存储。那么要实现一个框架肯定不能一股脑按这个逻辑写，要遵守设计规范讲各个功能模块拆分开来。那么这里我的实现方式是这样的(参考了 <a href="http://webmagic.io/">WebMagic</a> 教科书般的设计)：</p><p><img src="/img/tiny-crawler/crawler_structure.png"></p><h2 id="各个模块"><a href="#各个模块" class="headerlink" title="各个模块"></a>各个模块</h2><p>我们遵循单一职责原则，抽取出这些模块，使爬虫的逻辑更清晰。</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p><strong>Scheduler</strong> 负责存储所有应该爬取的链接，并且调度这些链接将他们分配给 <strong>Downloader</strong> 去真正下载页面。之所以叫调度器，是因为我们还可以根据不同的需求来按照不同的顺序分配这些应该爬取的链接，但是这里我们先实现最基本的功能，调度等着以后再扩展吧。</p><p>根据上面的结构图，<strong>Scheduler</strong> 应该实现的功能就是<strong>接收链接</strong>与<strong>调度下载</strong>（即按某种策略拿出一个链接给 <strong>Downloader</strong>）。那么我们定义接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">offer</span><span class="hljs-params">(String url)</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h3><p><strong>Downloader</strong> 拿到需要爬取的链接后，去网络上进行爬取，下载下来需要的页面再交给 <strong>Processor</strong> 去处理。</p><p>所以它的接口是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Downloader</span> </span>&#123;<br><br>    <span class="hljs-function">Page <span class="hljs-title">download</span><span class="hljs-params">(String url)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：这里的 <code>Page</code> 是我们自己定义的类，由于我们想要一个页面包含的内容不止有 HTML 内容，还想要能存放新的链接、该页面本身的基本信息等等，所以这里定义一个 Page 类来存放这些所有东西，也方便日后扩展。</p><h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p><strong>Processor</strong> 获取下载后的 Page，进行一些处理，这里的处理一般根据不同用户的需求都不相同，自定义程度比较高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processor</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Page page)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Saver"><a href="#Saver" class="headerlink" title="Saver"></a>Saver</h3><p><strong>Saver</strong> 用以保存我们处理后的数据。可以输出到控制台上，也可以保存到文件或者数据库中等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Saver</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Page page)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现各个模块"><a href="#实现各个模块" class="headerlink" title="实现各个模块"></a>实现各个模块</h2><p>那么整体框架搭好后，我们要为每个模块先做一个具体的实现类以供使用。那么首先从 <strong>Scheduler</strong> 开始。</p><h3 id="Scheduler-1"><a href="#Scheduler-1" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>最简单的 Scheduler，我们想实现先进先出，先来的链接最先爬取。那么具体的存储当然就是要用队列了，而 Java 中提供了许多种队列，应该使用哪种呢？这里为了避免多线程带来的同步问题，我们使用 <code>LinkedBlockingQueue</code>，这是一个线程安全的队列，可以放心使用。</p><p>同时为了避免链接重复，我们还定义一个 <code>Set</code> 来去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueScheduler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">offer</span><span class="hljs-params">(String url)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (set.add(url))<br>            queue.offer(url);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue.poll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Downloader-1"><a href="#Downloader-1" class="headerlink" title="Downloader"></a>Downloader</h3><p>下载器我们使用 apache 下的 http 包内的工具去得到页面返回的 response。由于篇幅较长放在下一篇文章中讲。</p><h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><p>我们要先知道我们需要页面中的什么信息，所以定义这个类。我这里就简单以这些信息做个示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> </span>&#123;<br>    <span class="hljs-comment">// 该页面的链接</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-comment">// 原始的 html 文档</span><br>    <span class="hljs-keyword">private</span> String html;<br>    <span class="hljs-comment">// 解析 html 后的 Jsoup 文档</span><br>    <span class="hljs-keyword">private</span> Document document;<br>    <span class="hljs-comment">// 该页面下的其他链接，即新种子</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; nextSeeds;<br>    <span class="hljs-comment">// 存放处理后的结果，以键值对形式存放比较万金油</span><br>    <span class="hljs-keyword">private</span> Map&lt;Object, Object&gt; results;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Page</span><span class="hljs-params">()</span> </span>&#123;<br>        nextSeeds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        results = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Page</span><span class="hljs-params">(String url, String html)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.url = url;<br>        <span class="hljs-keyword">this</span>.html = html;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略一大段 getter</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Processor-1"><a href="#Processor-1" class="headerlink" title="Processor"></a>Processor</h3><p>Downloader 下载完之后一个页面中应该只有 url 和原始的 html 文档，Processor 要干的事就是对页面进行解析，这里我们使用 <a href="https://jsoup.org/">Jsoup</a> 来解析原始的 html 文档，并再添加一些简单的逻辑做一些处理以拿到我们需要的数据（这里根据客户不同的需求实现方式都不相同）。除此之外 Processor 还需要将新的种子加入到 Scheduler 中。</p><p>由于 Processor 要做的事情比较多，我使用<strong>模板方法</strong>的设计模式思想来实现。先写一个抽象类定义模板方法，再由具体的子类来决定具体的实现细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Processor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>        setDocument(page);<br>        getResult(page);<br>        getNewSeeds(page);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDocument</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>        page.setDocument(Jsoup.parse(page.getHtml()));<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getResult</span><span class="hljs-params">(Page page)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getNewSeeds</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>        List&lt;String&gt; links = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Elements elements = page.getDocument().select(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            <span class="hljs-keyword">if</span> (!element.attr(<span class="hljs-string">&quot;abs:href&quot;</span>).equals(<span class="hljs-string">&quot;&quot;</span>))<br>                links.add(element.attr(<span class="hljs-string">&quot;abs:href&quot;</span>));<br>        &#125;<br>        page.setNextSeeds(links);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleTextProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getResult</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>        Document document = page.getDocument();<br>        String title = document.title();<br>        String text = document.text();<br>        Map&lt;String, String&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        result.put(<span class="hljs-string">&quot;title&quot;</span>, title);<br>        result.put(<span class="hljs-string">&quot;text&quot;</span>, text);<br>        page.setResults(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Saver-1"><a href="#Saver-1" class="headerlink" title="Saver"></a>Saver</h3><p>Saver 只需要把得到的结果存到想要的地方就可以了。这里以最简单的打印到控制台为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleSaver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Saver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>        Map&lt;Object, Object&gt; result = page.getResults();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : result.entrySet()) &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;===============================================================&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此就实现完最简单版本的这些模块了（除了 Downloader），本文只是这个系列的一个开头，梳理一下爬虫框架的搭建思想以及方法。同时也有助于大家更好地去阅读开源爬虫框架的源码，下一篇文章将讲讲 Downloader 的实现以及如何将这一系列操作串在一起去执行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要目的是&lt;strong&gt;学习各种开源爬虫框架的实现原理&lt;/strong&gt;并且造一个小轮子，其中会参考许多项目的思想如 &lt;a href=&quot;http://webmagic.io/&quot;&gt;WebMagic&lt;/a&gt; 等。这里只追求最简单的逻辑与最小的代码量实现一个&lt;strong&gt;够用&lt;/strong&gt;的爬虫，并且会尽可能地遵循设计原则与使用设计模式。另，本文基于 Java 语言。&lt;/p&gt;</summary>
    
    
    
    <category term="小项目" scheme="https://congregalis.github.io/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://congregalis.github.io/tags/Java/"/>
    
    <category term="爬虫" scheme="https://congregalis.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>路径总和 III - 前缀和还能这样用！</title>
    <link href="https://congregalis.github.io/2021/09/30/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III-%E5%89%8D%E7%BC%80%E5%92%8C%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%94%A8%EF%BC%81/"/>
    <id>https://congregalis.github.io/2021/09/30/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III-%E5%89%8D%E7%BC%80%E5%92%8C%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%94%A8%EF%BC%81/</id>
    <published>2021-09-29T16:19:23.000Z</published>
    <updated>2021-09-29T16:28:18.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>题目详情可看<a href="https://leetcode-cn.com/problems/path-sum-iii/">这里</a></p><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>示例：</p><p><img src="/img/pathsum3/pathsum3-1-tree.jpg"></p><blockquote><p>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<br>输出：3<br>解释：和等于 8 的路径有 3 条，如图所示。</p></blockquote><h2 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h2><p>首先题目要求计算所有符合的路径，那必然是需要遍历整个树的。而要遍历树，最常见的方法就是 dfs 和 bfs 了，这题我就使用 dfs 来对树进行遍历。</p><p>其次路径并不需要从根节点开始，所以任意一个结点都可以作为路径的开头，理解到这里最直观的想法就是把每个结点都当作是一个根节点，再往下去遍历搜寻合适的路径。</p><h2 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h2><p>那么首先我想到的方法（当然先是想到笨办法！）是在 dfs 的过程中去维护一个 list，这个 list 记录从根节点到某个结点所有结点的值。然后在每次遍历到某个结点的时候，从后往前的遍历整个 list 并计算路径的和（即相当于以<strong>当前结点</strong>为路径的尾所能得到的全部路径的和），这样的话就不用重复的去做 dfs 了。</p><p>当然还要注意<strong>回溯</strong>，在回溯的时候要把不应该存在于 list 中的结点从list中抹除。</p><p>具体来看看我的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        List&lt;Integer&gt; sum = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dfs(root, sum, targetSum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode curr, List&lt;Integer&gt; sum, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (curr.val == targetSum) ans++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sum.size() - <span class="hljs-number">1</span>, tmp = curr.val; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp += sum.get(i);<br>            <span class="hljs-keyword">if</span> (tmp == targetSum) ans++;<br>        &#125;<br><br>        sum.add(curr.val);<br>        <span class="hljs-keyword">if</span> (curr.left != <span class="hljs-keyword">null</span>) ans += dfs(curr.left, sum, targetSum);<br>        <span class="hljs-keyword">if</span> (curr.right != <span class="hljs-keyword">null</span>) ans += dfs(curr.right, sum, targetSum);<br>        sum.remove(sum.size() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外也可以使用前面想到的最直观的做法，也就是<strong>以每个结点为根节点（路径的开头）去寻找所有可能的路径</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dfs(root, targetSum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode curr, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = ddfs(curr, curr.val, targetSum);<br>        <span class="hljs-keyword">if</span> (curr.left != <span class="hljs-keyword">null</span>) ans += dfs(curr.left, targetSum);<br>        <span class="hljs-keyword">if</span> (curr.right != <span class="hljs-keyword">null</span>) ans += dfs(curr.right, targetSum);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ddfs</span><span class="hljs-params">(TreeNode curr, <span class="hljs-keyword">int</span> curSum, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (curSum == targetSum) ans += <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (curr.left != <span class="hljs-keyword">null</span>) ans += ddfs(curr.left, curSum + curr.left.val, targetSum);<br>        <span class="hljs-keyword">if</span> (curr.right != <span class="hljs-keyword">null</span>) ans += ddfs(curr.right, curSum + curr.right.val, targetSum);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀和的应用"><a href="#前缀和的应用" class="headerlink" title="前缀和的应用"></a>前缀和的应用</h2><p>上面的方法我们很容易想到，计算路径的过程中存在许多无用的重复计算。比如在计算 <code>1 - 2 - 3 - 4 - 5</code> 这条路径的时候，每经过一个结点都会再次重复计算前面所有结点的路径和。</p><p>从这我们又能想到，针对一个线性的数组来算路径和的时候我们通常都是这么做的？当然是用前缀和了！如 <code>1 - 2 - 3 - 4 - 5</code> 这条路径，我们把当前位置置为前面所有值与当前值的总和，就得到了前缀和 <code>1 - 3 - 6 - 10 - 15</code>。这样的话要想得到某个位置到某个位置之间的路径和时只需把对应位置的前缀和元素一减即可得到，如要得到<strong>位置2</strong>到<strong>位置4</strong>的路径和，那就是 <code>10 - 1 = 9</code> 即 <code>2 + 3 + 4</code>。</p><p>用在这题也是一样的，路径都是一条线，在遍历的时候存储根节点到当前节点的前缀和就可以了，完全可以把他当成是线性的。只是在<strong>回溯</strong>的时候要记得把应该去掉的前缀和删除。</p><p>在实现细节上，使用哈希表来记录前缀和，毕竟这个题的某个路径和可能不止存在1个。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        t = targetSum;<br><br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(root, root.val, map);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode curr, <span class="hljs-keyword">int</span> sum, Map&lt;Integer, Integer&gt; map)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (map.containsKey(sum - t))  ans += map.get(sum - t);<br><br>        map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (curr.left != <span class="hljs-keyword">null</span>) ans += dfs(curr.left, sum + curr.left.val, map);<br>        <span class="hljs-keyword">if</span> (curr.right != <span class="hljs-keyword">null</span>) ans += dfs(curr.right, sum + curr.right.val, map);<br>        map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这个题可以看出，遇到问题先想想最朴素的做法，然后从这个做法的缺点上入手再去寻找改进的思路，就能得到比较好的解法了。</p><p>除此之外前缀和也是一个很好的想法，不仅可以应用在线性的数据结构上，在树上同样能得到很好的应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目介绍&quot;&gt;&lt;a href=&quot;#题目介绍&quot; class=&quot;headerlink&quot; title=&quot;题目介绍&quot;&gt;&lt;/a&gt;题目介绍&lt;/h2&gt;&lt;p&gt;题目详情可看&lt;a href=&quot;https://leetcode-cn.com/problems/path-sum-iii/&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://congregalis.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DFS" scheme="https://congregalis.github.io/tags/DFS/"/>
    
    <category term="前缀和" scheme="https://congregalis.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>React初体验——井字棋及其改进</title>
    <link href="https://congregalis.github.io/2021/07/10/React%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%95%E5%AD%97%E6%A3%8B%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B/"/>
    <id>https://congregalis.github.io/2021/07/10/React%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E4%BA%95%E5%AD%97%E6%A3%8B%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B/</id>
    <published>2021-07-10T06:13:41.000Z</published>
    <updated>2021-07-10T06:43:33.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近突然想玩玩前端了，想学点新东西，于是便把矛头转向 React，研究了一下确实很不错。它的<strong>组件化</strong>管理方式我非常喜欢，而且不同于 Vue，以<strong>声明式</strong>的方式来创建 UI 也非常的有意思。这篇文章主要就讲讲我跟着官网上<a href="https://react.docschina.org/tutorial/tutorial.html">井字棋的教程</a>进行学习，并根据官网提供的可改进内容进行改进的过程。</p><p>本文的源码可以在<a href="https://github.com/Congregalis/Tic-Tac-Toe">这个地方</a>找到。<br>演示效果在<a href="http://tic-tac-toe-green-one.vercel.app/">这里</a>看。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>基础的井字棋步骤我就不多说辣，官网上讲的非常详细且易懂，实现完的大致效果如下：<br><img src="/img/tic-tac-toe/base.png" alt="跟着官方教程学完后的效果"></p><p>可以看出还是比较简陋的。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>教程上给的可改进内容如下：</p><ol><li>在游戏历史记录列表显示每一步棋的坐标，格式为 (列号, 行号)。</li><li>在历史记录列表中加粗显示当前选择的项目。</li><li>使用两个循环来渲染出棋盘的格子，而不是在代码里写死（hardcode）。</li><li>添加一个可以升序或降序显示历史记录的按钮。</li><li>每当有人获胜时，高亮显示连成一线的 3 颗棋子。</li><li>当无人获胜时，显示一个平局的消息。</li></ol><p>下面我们来一个一个看看实现思路。</p><h3 id="在游戏历史记录列表显示每一步棋的坐标，格式为-列号-行号"><a href="#在游戏历史记录列表显示每一步棋的坐标，格式为-列号-行号" class="headerlink" title="在游戏历史记录列表显示每一步棋的坐标，格式为 (列号, 行号)"></a>在游戏历史记录列表显示每一步棋的坐标，格式为 (列号, 行号)</h3><p>这个是最简单的，首先要清楚 history 这个数据结构是什么样的。</p><p>history 是一个历史记录<strong>列表</strong>，列表中的每个元素是一个 <strong>map</strong>，其中包含 squares 等信息。为了方便，我们可以在这个列表里添加一个 currStep（String类型），用来记录当前下棋的位置坐标，然后在每次添加新的 history 的时候把这个坐标加进去就行了。</p><p>下棋时（即会添加新的 history ）加入当前位置坐标：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params">i</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> history = <span class="hljs-built_in">this</span>.state.history.slice(<span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.state.stepNumber + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">const</span> current = history[history.length - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">const</span> currStep = <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">3</span>+<span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;, &#x27;</span> + (i%<span class="hljs-number">3</span>+<span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;)&#x27;</span>;<br>    ...<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>        history: history.concat([&#123;<br>        squares: squares,<br>        currStep: currStep,<br>        &#125;]),<br>        ...<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>显示时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> moves = history.map(<span class="hljs-function">(<span class="hljs-params">step, move</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> desc = move ?<br>        <span class="hljs-string">&#x27;Go to step #&#x27;</span> + move :<br>        <span class="hljs-string">&#x27;Go to game start&#x27;</span>;<br>    <br>    <span class="hljs-keyword">return</span> (<br>    &lt;li ...&gt;<br>        &lt;button className=<span class="hljs-string">&#x27;button&#x27;</span> onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.jumpTo(move)&#125;&gt;&#123;desc&#125;&lt;/button&gt;<br>        &amp;nbsp;&amp;nbsp;<br>        &lt;span&gt;&#123;step[<span class="hljs-string">&#x27;currStep&#x27;</span>] ? <span class="hljs-string">&#x27;coordinate: &#x27;</span> + step[<span class="hljs-string">&#x27;currStep&#x27;</span>] : <span class="hljs-string">&#x27;&#x27;</span> &#125;&lt;/span&gt;<br>    &lt;/li&gt;<br>    );<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="在历史记录列表中加粗显示当前选择的项目"><a href="#在历史记录列表中加粗显示当前选择的项目" class="headerlink" title="在历史记录列表中加粗显示当前选择的项目"></a>在历史记录列表中加粗显示当前选择的项目</h3><p>这一步改进就要涉及到使用 react 动态改变 className 或者是动态修改样式了。</p><p>我这里采用动态修改 style 的方式，在遍历 history 数组渲染 li 标签的时候判断一下当前的序号是否是当前步即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &lt;li <br>    key=&#123;move&#125; <br>    style=&#123;&#123;<span class="hljs-attr">fontWeight</span>: (move === <span class="hljs-built_in">this</span>.state.stepNumber) ? <span class="hljs-string">&quot;bold&quot;</span> : <span class="hljs-string">&quot;&quot;</span>&#125;&#125;<br>    &gt;<br>    ...<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><h3 id="使用两个循环来渲染出棋盘的格子，而不是在代码里写死（hardcode）"><a href="#使用两个循环来渲染出棋盘的格子，而不是在代码里写死（hardcode）" class="headerlink" title="使用两个循环来渲染出棋盘的格子，而不是在代码里写死（hardcode）"></a>使用两个循环来渲染出棋盘的格子，而不是在代码里写死（hardcode）</h3><p>这里我写的比较难懂，其实还是使用 map 的方式来遍历渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> row = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> cell = [<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br>    [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>];<br><span class="hljs-keyword">let</span> checkerboard = row.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> (<br>    &lt;div className=<span class="hljs-string">&quot;board-row&quot;</span> key=&#123;index&#125;&gt;<br>    &#123;<br>        cell.map(<span class="hljs-function">(<span class="hljs-params">item1, index1</span>) =&gt;</span> <br>        index === index1 ? <br>            item1.map(<span class="hljs-function">(<span class="hljs-params">item2, index2</span>) =&gt;</span> (<br>            <span class="hljs-built_in">this</span>.renderSquare(item2)<br>            )) :<br>            <span class="hljs-string">&quot;&quot;</span><br>        )<br>    &#125;<br>    &lt;/div&gt;<br>));<br></code></pre></td></tr></table></figure><h3 id="添加一个可以升序或降序显示历史记录的按钮"><a href="#添加一个可以升序或降序显示历史记录的按钮" class="headerlink" title="添加一个可以升序或降序显示历史记录的按钮"></a>添加一个可以升序或降序显示历史记录的按钮</h3><p>列表本身就有一个 reverse 函数来逆转自身的排列。所以我们只需要再定义一个 flag 来判断是升序还是降序，然后每次执行的时候 reverse 一下 moves 列表就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">reverseHistory = <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> isAscendingOrder = <span class="hljs-built_in">this</span>.state.isAscendingOrder;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>        isAscendingOrder: !isAscendingOrder<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>reverse 操作我放在了每次定义 moves 之后。判断若是升序就不倒转，若是降序就倒转。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.state.isAscendingOrder) &#123;<br>    moves.reverse()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="每当有人获胜时，高亮显示连成一线的-3-颗棋子"><a href="#每当有人获胜时，高亮显示连成一线的-3-颗棋子" class="headerlink" title="每当有人获胜时，高亮显示连成一线的 3 颗棋子"></a>每当有人获胜时，高亮显示连成一线的 3 颗棋子</h3><p>实现这个功能的时候出了很多bug，还是挺麻烦的（其实还是因为我太菜）。</p><p>核心思路就是：在计算胜利者时多保存一个信息，这个信息用来<strong>保存是哪条线连成了三连棋子</strong>（其实就是三连棋子的位置）。然后在渲染棋盘的时候<strong>动态改变 style</strong> ，如果是连成三连棋子的位置就设置成成你想要的高亮 style （或者使用 css ）。</p><p>核心代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">renderSquare</span>(<span class="hljs-params">i</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> line = <span class="hljs-built_in">this</span>.props.winnerLines;<br>    <span class="hljs-keyword">const</span> [a, b, c] = line;<br>    <span class="hljs-keyword">let</span> className =  (i === a || i === b || i === c) ? <span class="hljs-string">&#x27;squareWinner&#x27;</span> : <span class="hljs-string">&#x27;square&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> (<br>        &lt;Square<br>        key=&#123;i&#125;<br>        className=&#123;className&#125;<br>        value=&#123;<span class="hljs-built_in">this</span>.props.squares[i]&#125;<br>        onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.props.onClick(i)&#125;<br>        /&gt;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>还有其他细节可以参考我的源码，在文章最后放出</p><h3 id="当无人获胜时，显示一个平局的消息"><a href="#当无人获胜时，显示一个平局的消息" class="headerlink" title="当无人获胜时，显示一个平局的消息"></a>当无人获胜时，显示一个平局的消息</h3><p>当胜利者未出现，且棋盘被填满了，那就说明平局了。</p><p>判断棋盘是否被填满</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">allFilled</span>(<span class="hljs-params">squares</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; squares.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> square = squares[i];<br>    <span class="hljs-keyword">if</span> (square == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>status 显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> status;<br><span class="hljs-keyword">if</span> (winner) &#123;<br>    status = <span class="hljs-string">&#x27;Winner: &#x27;</span> + winner;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    status = allFilled(current.squares) ?<br>    <span class="hljs-string">&#x27;Draw &#x27;</span> : <span class="hljs-string">&#x27;Next player: &#x27;</span> + (<span class="hljs-built_in">this</span>.state.xIsNext ? <span class="hljs-string">&#x27;X&#x27;</span> : <span class="hljs-string">&#x27;O&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p><img src="/img/tic-tac-toe/mine.png" alt="改进后的效果"></p><p>演示效果可以去<a href="https://github.com/Congregalis/Tic-Tac-Toe">我的仓库</a>看图，也可以直接<a href="https://tic-tac-toe-green-one.vercel.app/">在线看</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是本次我对 React 初次学习的全部内容了，当然对这个井字棋的可改进内容绝不止如此，实现这些改进内容的方式也绝不止如此，在以后的学习中还希望多多努力，深入挖掘更多的细节！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;最近突然想玩玩前端了，想学点新东西，于是便把矛头转向 React，研究了一下确实很不错。它的&lt;strong&gt;组件化&lt;/strong&gt;管理方式</summary>
      
    
    
    
    <category term="小项目" scheme="https://congregalis.github.io/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="前端" scheme="https://congregalis.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://congregalis.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>使用torchtext处理文本数据集</title>
    <link href="https://congregalis.github.io/2021/07/07/%E4%BD%BF%E7%94%A8torchtext%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>https://congregalis.github.io/2021/07/07/%E4%BD%BF%E7%94%A8torchtext%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2021-07-07T11:48:44.000Z</published>
    <updated>2021-07-07T18:03:31.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在平时的科研任务中，数据集的处理是很重要的一个环节。模型的输入往往不可能就是单纯的纯文本，并且模型的训练通常也需要分很多个epoch进行训练，所以数据集的处理尤为重要。</p><p>这里我以 <a href="https://pytorch.org/text/stable/index.html">torchtext 库</a>、<a href="https://rajpurkar.github.io/SQuAD-explorer/">SQuAD 数据集</a>为例，展示一下数据处理的流程。</p><span id="more"></span><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="使用到的数据结构介绍"><a href="#使用到的数据结构介绍" class="headerlink" title="使用到的数据结构介绍"></a>使用到的数据结构介绍</h3><ul><li>Field: 字段类型。如果把整个数据集比作一个表格，那么 Field 就是这个表格的列。</li><li>TabularDataset: 用以把原始数据集（json 或者 csv 格式）转换为 torchtext 特定格式的数据集（）。</li><li>BucketIterator: 迭代器数据类型，用以训练时迭代。并且在同一个 batch size 中会尽量放入句子长度相似的句子。</li></ul><h3 id="step-1-创建-Field"><a href="#step-1-创建-Field" class="headerlink" title="step 1. 创建 Field"></a>step 1. 创建 Field</h3><p>SQuAD 数据集是一个 json 格式的数据集。<br>这里我想要处理出的情况是：每个 case 含有 <strong>文本段落</strong>、<strong>问题</strong>、<strong>答案</strong> </p><p>那么首先就要定义字段，即 Field , 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenize = <span class="hljs-keyword">lambda</span> x: x.split()<br><br>PARAGRAPH = Field(sequential=<span class="hljs-literal">True</span>, tokenize=tokenize, lower=<span class="hljs-literal">True</span>)<br>QUESTION = Field(sequential=<span class="hljs-literal">True</span>, tokenize=tokenize, lower=<span class="hljs-literal">True</span>)<br>ANSWER = Field(sequential=<span class="hljs-literal">True</span>, tokenize=tokenize, lower=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>由于这三个字段都是一段文本序列，所以简单定义 <code>sequential=True</code> 即可，比较重要的是 <code>tokenize</code> ，即分词。因为 SQuAD 是一个英文数据集，所以简单以空格为分隔符进行划分即可（再复杂一点要考虑到标点符号的分隔）。所以我就使用 <code>split()</code> 函数进行分词。</p><p>Field 还提供方法建立词汇表，这是为了建立 <strong>id 到 单词 的映射</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">PARAGRAPH.build_vocab(train)<br>QUESTION.build_vocab(train)<br>ANSWER.build_vocab(train)<br></code></pre></td></tr></table></figure><h3 id="step-2-定义-TabularDataset"><a href="#step-2-定义-TabularDataset" class="headerlink" title="step 2. 定义 TabularDataset"></a>step 2. 定义 TabularDataset</h3><p>这一步可以说是自定义 torch 格式的 Dataset。原始的数据集可以是 json 格式或者是 csv 格式，这里我以 json 格式的数据集为例。只要<strong>把 fields 对应上之前定义的 Field</strong> ，它就会把数据集组装成我们要的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">train, dev = TabularDataset.splits(<br>    path=<span class="hljs-string">&#x27;.data/squad/&#x27;</span>,<br>    train=<span class="hljs-string">&#x27;train-v1.1-preprocessed.json&#x27;</span>, validation=<span class="hljs-string">&#x27;dev-v1.1-preprocessed.json&#x27;</span>,<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;json&quot;</span>,<br>    fields=&#123;<br>        <span class="hljs-string">&#x27;paragraph&#x27;</span>: (<span class="hljs-string">&#x27;paragraph&#x27;</span>, PARAGRAPH),<br>        <span class="hljs-string">&#x27;question&#x27;</span>: (<span class="hljs-string">&#x27;question&#x27;</span>, QUESTION),<br>        <span class="hljs-string">&#x27;answer&#x27;</span>: (<span class="hljs-string">&#x27;answer&#x27;</span>, ANSWER),<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="step-3-使用-BucketIterator"><a href="#step-3-使用-BucketIterator" class="headerlink" title="step 3. 使用 BucketIterator"></a>step 3. 使用 BucketIterator</h3><p>将数据集转变为可迭代的形式，并将所有的词都转换为对应 id ，所以前面的 <code>build_vocab</code> 很重要。</p><p>这里使用 BucketIterator 是为了在同一个 batch size 中尽量放入句子长度相似的句子。为什么要这么做呢？在模型处理序列数据时，会将其转化成 tensor 形式，而每个句子长度不一，tensor 都是固定的大小，所以这样显然会出错。为了避免这个错误，通常会加入 &lt;pad&gt; token 来补全长度不足的句子。这里使用 BucketIterator 是为了使每一个 batch 中用以补充的 &lt;pad&gt; token 尽可能少，因为这个 token 显然是没有任何语义信息的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">train_iter, dev_iter = BucketIterator.splits(<br>    (train, dev),<br>    batch_sizes=(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>),  <span class="hljs-comment"># tmd没加s的报错找了好久</span><br>    device=torch.device(<span class="hljs-string">&#x27;cuda:2&#x27;</span>), <span class="hljs-comment"># 选择 cpu 或者 gpu</span><br>    sort_key=<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x.question), <span class="hljs-comment"># 不同个 batch 中的划分方式，这里我以 问题的长度 作为 sort_key ，即让每个 batch 中的问题长度都相似</span><br>    sort_within_batch=<span class="hljs-literal">False</span>,<br>    repeat=<span class="hljs-literal">True</span><br>)<br></code></pre></td></tr></table></figure><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>经过了这三个步骤就基本上得到了自己想要的 torch 形式的数据集输入，当然其中还有许多地方可以自定义，详细请可以参考 torchtext 官网。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在平时的科研任务中，数据集的处理是很重要的一个环节。模型的输入往往不可能就是单纯的纯文本，并且模型的训练通常也需要分很多个epoch进行训练，所以数据集的处理尤为重要。&lt;/p&gt;
&lt;p&gt;这里我以 &lt;a href=&quot;https://pytorch.org/text/stable/index.html&quot;&gt;torchtext 库&lt;/a&gt;、&lt;a href=&quot;https://rajpurkar.github.io/SQuAD-explorer/&quot;&gt;SQuAD 数据集&lt;/a&gt;为例，展示一下数据处理的流程。&lt;/p&gt;</summary>
    
    
    
    <category term="科研日常" scheme="https://congregalis.github.io/categories/%E7%A7%91%E7%A0%94%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="dataset" scheme="https://congregalis.github.io/tags/dataset/"/>
    
    <category term="pytorch" scheme="https://congregalis.github.io/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>从crawler4j源码中看wait与notify</title>
    <link href="https://congregalis.github.io/2021/06/01/%E4%BB%8Ecrawler4j%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9C%8Bwait%E4%B8%8Enotify/"/>
    <id>https://congregalis.github.io/2021/06/01/%E4%BB%8Ecrawler4j%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9C%8Bwait%E4%B8%8Enotify/</id>
    <published>2021-06-01T02:06:23.000Z</published>
    <updated>2021-05-31T09:49:07.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><a href="https://github.com/yasserg/crawler4j">crawler4j</a> 是一个开源的 Java 爬虫框架，关于它的入门简单使用方法在前文中有过介绍。拥有4k多个 star 的项目，相信其源码值得我去研究，所以才写下这篇文章。如有错误欢迎<a href="https://congregalis.gitee.io/about/#%E6%83%B3%E5%92%8C%E6%88%91%E8%AF%B4%E4%BB%80%E4%B9%88">联系我</a>指正！</p><p>其实本文的重点不在于研究 crawler4j 源码中的各种逻辑、细节等，主要还是以 crawler4j 这个例子来看 Java 中 <strong>wait</strong> 与 <strong>notify</strong> 的使用，看看热门开源项目里是如何使用如何编码的。</p><span id="more"></span><p>想快速了解的话，你可以直接看<a href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91">核心逻辑部分</a>，也可以直接看<a href="#%E7%A9%B6%E6%9E%81%E7%AE%80%E6%98%93%E7%89%88%E5%AE%9E%E7%8E%B0">究极简单版wait/notify使用</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>crawler4j 中最重要的两个类莫过于 <strong>CrawlController</strong> 和 <strong>WebCrawler</strong> 了，一个是用于<strong>设置与开启爬虫</strong>，而另一个则是<strong>爬虫的核心实现类</strong>。这里讨论的代码基本都在 <strong>CrawlController</strong> 类中。</p><p>熟悉的同学都知道，在开启 controller 时一般有两个用法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用法1：阻塞式，当爬虫线程都结束后才会执行这行以后的代码</span><br>controller.start(factory, numberOfCrawlers);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用法2：非阻塞式，在 start 以后， waitUntilFinish 以前的代码都会立刻执行，在 waitUntilFinish 处阻塞</span><br>controller.startNonBlocking(factory, numberOfCrawlers);<br><span class="hljs-comment">// 这中间的代码都会异步执行</span><br>controller.waitUntilFinish();<br></code></pre></td></tr></table></figure><p>这个的源码部分就是本文重点要讨论的 <strong>wait</strong> 与 <strong>notify</strong> 的使用。</p><h3 id="两个重要变量"><a href="#两个重要变量" class="headerlink" title="两个重要变量"></a>两个重要变量</h3><p>首先，在 <strong>CrawlController</strong> 中定义了两个这个功能需要的重要变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Is the crawling of this session finished?</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> finished;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Object waitingLock = <span class="hljs-keyword">new</span> Object();<br><br></code></pre></td></tr></table></figure><ul><li>finished 用于<strong>判断此次爬取是否已结束</strong></li><li>waitingLock 则是用于<strong>加锁</strong></li></ul><h3 id="阻塞式-start-方法"><a href="#阻塞式-start-方法" class="headerlink" title="阻塞式 start 方法"></a>阻塞式 start 方法</h3><p>为了只关注重要内容，其他部分代码我以注释的形式带过。</p><p>我们调用 start 方法的入口在这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Start the crawling session and wait for it to finish.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> crawlerFactory</span><br><span class="hljs-comment">*            factory to create crawlers on demand for each thread</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> numberOfCrawlers</span><br><span class="hljs-comment">*            the number of concurrent threads that will be contributing in</span><br><span class="hljs-comment">*            this crawling session.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> &lt;T&gt; Your class extending WebCrawler</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> &lt;T extends WebCrawler&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(WebCrawlerFactory&lt;T&gt; crawlerFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">int</span> numberOfCrawlers)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.start(crawlerFactory, numberOfCrawlers, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>它会去调用另一个有更多参数的 start 方法，多的参数就是 <code>isBlocking</code> ，这个参数表示<strong>是否需要阻塞</strong>，具体作用在下面这个 start 方法的注释中给出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T extends WebCrawler&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">final</span> WebCrawlerFactory&lt;T&gt; crawlerFactory, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numberOfCrawlers, <span class="hljs-keyword">boolean</span> isBlocking)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 根据提供的工厂类 crawlerFactory 构造指定数量的线程并使它们开始运行</span><br><br>    <span class="hljs-comment">// 创建一个监控线程 monitorThread 如下</span><br>    Thread monitorThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (waitingLock) &#123;<br><br>                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                        <span class="hljs-comment">// 设置的监控循环周期</span><br>                        sleep(config.getThreadMonitoringDelaySeconds());<br>                        <span class="hljs-keyword">boolean</span> someoneIsWorking = <span class="hljs-keyword">false</span>;<br>                        <br>                        <span class="hljs-comment">//  第一部分： </span><br>                        <span class="hljs-comment">//      观察每个 爬虫线程 是否正常运行，若没有正常运行则采取相应措施</span><br>                        <span class="hljs-comment">//      第一部分的代码省略，有兴趣可以去 github 看</span><br>                    <br>                        <span class="hljs-comment">//  第二部分: </span><br>                        <span class="hljs-comment">//      查看是否还有正在工作的线程，若没有则准备退出并关闭资源</span><br>                        <span class="hljs-comment">//      这个部分也是我们经常看到的 &quot;It looks like no thread is working, waiting for ...&quot; 等 打印日志的所在源码部分</span><br>                        <span class="hljs-comment">//      在关闭时会调用 notifyAll</span><br>                        <span class="hljs-keyword">if</span> (!someoneIsWorking &amp;&amp; shutOnEmpty) &#123;<br>                            <span class="hljs-comment">// 再次确保无线程工作且队列中无 URL 等待爬取</span><br><br>                            <span class="hljs-comment">// 释放资源</span><br><br>                            waitingLock.notifyAll();<br><br>                            <span class="hljs-comment">// 释放资源</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                <span class="hljs-keyword">if</span> (config.isHaltOnError()) &#123;<br>                    <span class="hljs-comment">// 发生了某个错误</span><br>                    setError(e);<br>                    <span class="hljs-keyword">synchronized</span> (waitingLock) &#123;<br>                        <span class="hljs-comment">// 释放资源</span><br><br>                        waitingLock.notifyAll();<br><br>                        <span class="hljs-comment">// 释放资源</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    logger.error(<span class="hljs-string">&quot;Unexpected Error&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;);<br><br>    monitorThread.start();<br><br>    <span class="hljs-comment">// 如果需要阻塞，那么就调用 waitUntilFinish 这个方法，代码执行到这就会阻塞住</span><br>    <span class="hljs-keyword">if</span> (isBlocking) &#123;<br>        waitUntilFinish();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看到，阻塞的地方在最后几行，也就是监控线程开启后的 <strong>waitUntilFinish</strong> 方法。</p><p>监控线程在监控到线程都运行完后，调用 <code>waitingLock.notifyAll()</code> 从而使这里的阻塞结束，那么这是如何做到的呢，我们再来看 <strong>waitUntilFinish</strong> 方法。</p><h3 id="waitUntilFinish-方法如何使-start-阻塞"><a href="#waitUntilFinish-方法如何使-start-阻塞" class="headerlink" title="waitUntilFinish 方法如何使 start 阻塞"></a>waitUntilFinish 方法如何使 start 阻塞</h3><p>这个方法的源码很短，我直接放出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Wait until this crawling session finishes.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitUntilFinish</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!finished) &#123;<br>        <span class="hljs-keyword">synchronized</span> (waitingLock) &#123;<br>            <span class="hljs-keyword">if</span> (config.isHaltOnError()) &#123;<br>                Throwable t = getError();<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; config.isHaltOnError()) &#123;<br>                    <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>                        <span class="hljs-keyword">throw</span> (RuntimeException)t;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> Error) &#123;<br>                        <span class="hljs-keyword">throw</span> (Error)t;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;error on monitor thread&quot;</span>, t);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (finished) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 主动让出并等待锁资源</span><br>                waitingLock.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                logger.error(<span class="hljs-string">&quot;Error occurred&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，在 start 方法和 waitUntilFinish 方法中都有 <strong>synchronized</strong> 来修饰关键的代码块，并且争夺的都是同一个锁 <strong>waitingLock</strong>。这意味着一方执行，就会有另一方被阻塞。我们希望的是 <strong>waitUntilFinish 一直被阻塞，直到爬虫线程都执行完（也就是 start 方法中对应的 synchronized 方法块里的内容）后，再让 waitUntilFinish 方法结束</strong>。这也就是源码中对这部分的处理，同时也是 wait 和 notify 使用的思想。</p><h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><p>再来理一遍源码这块的逻辑：</p><ol><li>monitorThread 的 run 方法中<strong>使用 synchronized 获取锁 waitingLock</strong>，并<strong>循环检查</strong>是否所有爬虫线程、爬虫任务都执行完毕。</li><li>waitUntilFinish <strong>使用 synchronized 获取锁 waitingLock</strong>，并<strong>根据变量 isFinished 检查爬取过程是否结束</strong>，若结束则直接返回；若未结束，则<strong>调用 wait 方法让出资源</strong>给 monitorThread 的 run 方法。</li><li>即使 waitUntilFinish 在调用 wait 方法后又获取到了锁 waitingLock ，它也会根据爬取是否结束 isFinished 来判断是否要再次进入循环调用 wait 方法。</li><li>monitorThread 在检查到所有爬虫线程、爬虫任务都执行完毕后，<strong>调用 notifyAll 方法</strong>（和 notify 一样，只是对所有竞争锁资源的线程都发送通知）来<strong>让 waitUntilFinish 继续从 wait 处执行下去</strong>。</li><li>waitUntilFinish 获得锁资源，并从调用 wait 方法后的代码继续向下执行，<strong>在循环判断 isFinished 时发现爬取过程结束了，则直接返回，整个过程结束</strong>。</li></ol><p>其中也还有很多细节没有提及，如延时的设置、循环监控周期、资源的释放等等，由于不是本文关注的重点内容，可以自己参照源码理解一下。</p><h2 id="透过现象看本质"><a href="#透过现象看本质" class="headerlink" title="透过现象看本质"></a>透过现象看本质</h2><p>不难看出其实本质就是<strong>某个线程调用 wait 方法主动让出锁给另一个线程，然后另一个线程在执行完任务后调用 notify/notifyAll 来通知它执行完了以让它开始抢占锁</strong>。</p><p>其中还有一些细节：</p><ul><li>调用 notify 后，调用 wait 的线程<strong>并不会马上获得锁资源</strong>，而是等调用 notify 的那个线程释放锁资源后它才能获得，也就是说即使线程调用了 notify 方法，可能也要等到他退出 synchronized 代码块后，其他线程才能获得锁资源</li><li>调用 wait 释放锁，又重新获得锁后，代码会<strong>从 wait 方法下面的那一行继续向下执行</strong>，而不会去回到 synchronized 代码块开始的地方执行，这也是为什么源码中要使用 while 循环去重复获取锁资源。因为如果没有这层循环而该线程在释放锁后重新获取锁时其实爬取过程还没结束（也就是 isFinished 是 False），那 waitUntilFinish 就会直接结束</li><li>wait 其实<strong>可以设置超时时长</strong> wait(long timeout)，在 timeout 时间后唤醒自己，这就相当于 timeout 时间后有人来通知他可以去抢锁资源了</li></ul><h3 id="究极简易版实现"><a href="#究极简易版实现" class="headerlink" title="究极简易版实现"></a>究极简易版实现</h3><p>为了加深理解，自己动手实现一下 crawler4j 这个机制的究极简易版如下（注意只是实现 <strong>wait/notify</strong> 机制）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> thread_practice;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotify</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object waitingLock = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isFinished = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (waitingLock) &#123;<br>            isFinished = <span class="hljs-keyword">false</span>;<br>            System.out.println(<span class="hljs-string">&quot;doing sth...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;done.&quot;</span>);<br>            isFinished = <span class="hljs-keyword">true</span>;<br>            waitingLock.notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitUntilFinish</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (waitingLock) &#123;<br>            <span class="hljs-keyword">if</span> (isFinished) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                waitingLock.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WaitNotify wn = <span class="hljs-keyword">new</span> WaitNotify();<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; wn.start()).start();<br>        wn.waitUntilFinish();<br>        System.out.println(<span class="hljs-string">&quot;continue another thing...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/waitnotify/before.png" alt="执行程序5秒之内"><br><img src="/img/waitnotify/after.png" alt="执行程序5秒之后"></p><p>可以看到主线程确实是阻塞在了 <code>wn.waitUntilFinish()</code> 这个地方，在5秒之后才继续执行下去。<br>其逻辑和前面几节我的解释一样，是只提取了核心部分的简化版。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文结合 crawler4j 中实际使用的例子对实际场景中如何使用 wait 与 notify 进行了介绍与讨论，也根据 crawler4j 中的场景实现了一个简易版功能。线程之间的通信离不开 wait 与 notify ，当然也不止 wait 与 notify ，我会在以后对这方面做更深入的研究。</p><p>本文有什么错误欢迎<a href="https://congregalis.gitee.io/about/#%E6%83%B3%E5%92%8C%E6%88%91%E8%AF%B4%E4%BB%80%E4%B9%88">联系我</a>指正。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>这里只是单个线程通知单个线程任务执行完毕，如果是多个线程通知单个线程的场景怎么处理呢？</p><ul><li>如果是<strong>多个线程都执行完了，才通知某个线程</strong>，那可以参照 crawler4j 的方式，使用一个<strong>监控线程</strong>去循环检查所有线程是否执行完</li><li>如果是<strong>多个线程中的某个</strong>执行完了就要通知，如何实现？</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yasserg/crawler4j&quot;&gt;crawler4j&lt;/a&gt; 是一个开源的 Java 爬虫框架，关于它的入门简单使用方法在前文中有过介绍。拥有4k多个 star 的项目，相信其源码值得我去研究，所以才写下这篇文章。如有错误欢迎&lt;a href=&quot;https://congregalis.gitee.io/about/#%E6%83%B3%E5%92%8C%E6%88%91%E8%AF%B4%E4%BB%80%E4%B9%88&quot;&gt;联系我&lt;/a&gt;指正！&lt;/p&gt;
&lt;p&gt;其实本文的重点不在于研究 crawler4j 源码中的各种逻辑、细节等，主要还是以 crawler4j 这个例子来看 Java 中 &lt;strong&gt;wait&lt;/strong&gt; 与 &lt;strong&gt;notify&lt;/strong&gt; 的使用，看看热门开源项目里是如何使用如何编码的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术小技巧" scheme="https://congregalis.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="Java" scheme="https://congregalis.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://congregalis.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="crawler4j" scheme="https://congregalis.github.io/tags/crawler4j/"/>
    
  </entry>
  
  <entry>
    <title>前缀树/字典树的介绍及其简单应用</title>
    <link href="https://congregalis.github.io/2021/05/23/%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>https://congregalis.github.io/2021/05/23/%E5%89%8D%E7%BC%80%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</id>
    <published>2021-05-23T09:29:24.000Z</published>
    <updated>2021-05-24T12:44:26.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>前缀树是什么呢，先看一段维基百科上对它的定义：</p><blockquote><p>在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p></blockquote><p>要理解它首先要知道我们用这个东西的<strong>目的</strong>是什么，我举一个最直观的例子，比如要查询某个单词，很多搜索框都有<strong>搜索提示</strong>。你想查询“Hello”这个单词，当你输入“Hel”甚至输入“H”时可能提示框就已经出现了“Hello”这个单词。前缀树最常用的应用就在这里，即<strong>通过某一前缀去查到该前缀底下对应的有什么单词</strong>。有的人可能会问“那我直接把所有单词存在一个数组或者List，遍历一遍不是也能查到吗！”，确实，但你不觉得这样在查找某个单词的时候其实花了很多时间访问到了很多无用数据吗，十分的浪费时间。使用前缀树可以将查找某个单词的时间复杂度降到 **O(logn)**。</p><p>简单来说，首先它是一棵<strong>树</strong>，其次树中的<strong>每个结点</strong>都是<strong>当前的前缀</strong>，这样便于我们用更少的时间去查找某个元素。我再画一张图加深一下理解，为了图的简洁，假设当前单词库里就三个单词，“hi”、“me”和“min”。</p><p><img src="/img/trie/Trie_ex1.png"></p><span id="more"></span><p>好，我的废话可能有点多了，那么接下来就来看如何实现它。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先前缀树还是一课树，所以肯定少不了结点的<strong>插入</strong>、<strong>查找</strong>、<strong>删除</strong>等等。懂的了前缀树的本质，实现这些其实就是在树这个数据结构的基础上简单改变一下即可，<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">LC208</a>可以很好的练习前缀树的实现，这一节也根据这个来实现一个简单的前缀树。</p><h3 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h3><p>首先来定义结点，一颗树中的结点必然要有孩子结点，所以要有孩子结点的数组（或者列表），这里因为数据是英文单词，只有26个字母可以转移，所以定义一个长度为26的数组即可。</p><p><code>TrieNode[] childs = new TrieNode[26];</code></p><p>其次还需要知道当前是前缀还是已经查询到了结果，所以需要一个 boolean 来表示是否为需要查询的单词。</p><p><code>boolean isEnd;</code></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>创建一个根结点即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>    root = <span class="hljs-keyword">new</span> TrieNode();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入一个新数据时，将单词拆分成一个个字母，根据当前树中的结点判断：</p><ul><li>若当前前缀已存在，则直接进入该结点；</li><li>若当前前缀不存在，则插入新结点，记录当前前缀。</li><li>当遍历到单词最后一个字母时，记录当前结点为一个单词。</li></ul><p>例如在上面的例子中插入“him”这个单词如下图所示。</p><p><img src="/img/trie/Trie_add.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Inserts a word into the trie. */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>    TrieNode curr = root;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>        <span class="hljs-keyword">if</span> (curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>            curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> TrieNode();<br>        &#125;<br>        curr = curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br><br>    curr.isEnd = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找一个数据时，只需一个一个找结点匹配前缀即可，如下是查找到“min”这个单词的过程。</p><p><img src="/img/trie/Trie_Find1.png"></p><p>如下是查找“mid”这个单词失败的过程。</p><p><img src="/img/trie/Trie_Find2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Returns if the word is in the trie. */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>    TrieNode curr = root;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>        <span class="hljs-keyword">if</span> (curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        curr = curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> curr.isEnd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>到这就完成了简单的查找单词的前缀树/字典树，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> isEnd;<br>        TrieNode[] childs = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    TrieNode root;<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> TrieNode();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        TrieNode curr = root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) &#123;<br>                curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> TrieNode();<br>            &#125;<br>            curr = curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br><br>        curr.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        TrieNode curr = root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            curr = curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> curr.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        TrieNode curr = root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : prefix.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            curr = curr.childs[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>前缀树的应用还是很多的，除了上述的搜索提示外，还可以用于诸如如下场景：</p><ul><li><strong>字符串排序</strong>：字符串按字典顺序排序，可以使用前缀树</li><li>查找两个字符串的<strong>最长公共前缀</strong></li><li>查找某二进制数，且要<strong>按前缀顺序查找</strong></li></ul><p>这里，我重点介绍一下<strong>查找某二进制数</strong>这个应用</p><h3 id="二进制数上的应用"><a href="#二进制数上的应用" class="headerlink" title="二进制数上的应用"></a>二进制数上的应用</h3><p>这道<a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">LC421</a>就淋漓尽致地展现了前缀树在二进制数上的应用。题目如下：<br><img src="/img/trie/LC421.png"></p><p>这道题需要我们找到两个数的<strong>最大异或结果</strong>，且<strong>只能遍历一次数组</strong>。若是单纯比较两个数大小我们会怎么比呢？比如 <strong>123</strong> 和 <strong>120</strong> ，我们会先看<strong>百位</strong>，都是 <strong>1</strong>，那么再比较<strong>十位</strong>，都是 <strong>2</strong>，再比较<strong>个位</strong>，<strong>3</strong> 肯定比 <strong>0</strong> 大，于是我们得出结论：<strong>123 &gt; 120</strong>。同样的，在二进制数上也是一样的比较方式，比如 <strong>111</strong> 与 <strong>110</strong>，先比较<strong>最高位</strong>都是 <strong>1</strong>，再比较<strong>第二高位</strong>，也都是 <strong>1</strong>，再比较<strong>最后一位</strong> <strong>1 &gt; 0</strong>，于是我们知道 <strong>111 &gt; 110</strong>。</p><p>到这里，是不是就清楚了前缀树该怎么用了。正因为我们要从最高位比到最低位，前面的几个高位不就相当于是一个前缀吗，所以用上前缀树，我们可以遍历一遍数组，一边往树里添加数字，一遍从中寻找最大的异或值，这题就解出来了。</p><p>那么如何去寻找最大的异或值？我们都知道异或的计算是<strong>对应二进制位若相同则取0，不同则取1</strong>。我们要找最大的结果，那么肯定要<strong>尽量在高位找 1</strong> 呀。所以在我们查找时，<strong>寻找与当前数字当前位不同的即可</strong>，比如当前位是 <strong>0</strong>，那么我们就找 <strong>1</strong>；如果当前为是 <strong>1</strong>，那么我们就找 <strong>0</strong>。当然，如果找不到那就只能取一样的了，这一位总不能没有值。</p><p>下图我以查找 <strong>0100</strong> 的最大异或结果为例做一个演示：<br><img src="/img/trie/Trie_LC421.png" alt="查询 0100 的最大异或结果"></p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_BIT = <span class="hljs-number">30</span>; <span class="hljs-comment">// 最大位数</span><br><br>    <span class="hljs-keyword">private</span> Trie root = <span class="hljs-keyword">new</span> Trie();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            add(num);<br>            <span class="hljs-comment">// 每加入一个数字找一下这个数字和当前前缀树里的数的最大异或结果</span><br>            ans = Math.max(ans, find(num));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        Trie cur = root;<br><br>        <span class="hljs-comment">// 从最高位到最低位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = MAX_BIT; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>            <span class="hljs-keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算当前位是什么</span><br><br>            <span class="hljs-keyword">if</span> (bit == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-keyword">null</span>)<br>                    cur.left = <span class="hljs-keyword">new</span> Trie(); <span class="hljs-comment">// 如果不存在这个结点，就创建一个</span><br>                cur = cur.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (cur.right == <span class="hljs-keyword">null</span>)<br>                    cur.right = <span class="hljs-keyword">new</span> Trie(); <span class="hljs-comment">// 如果不存在这个结点，就创建一个</span><br>                cur = cur.right;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        Trie cur = root;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 从最高位到最低位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = MAX_BIT; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>            <span class="hljs-keyword">int</span> bit = (num &gt;&gt; k) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算当前位是什么</span><br><br>            <span class="hljs-keyword">if</span> (bit == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 当前位是 0，找 1</span><br>                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) &#123;<br>                    res = (res &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到 1 了，这一位可以直接置为 1</span><br>                    cur = cur.right;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 没找到</span><br>                    res = res &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 没有找到 1 ，这一位就只能是 0 了</span><br>                    cur = cur.left;<br>                &#125;   <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 当前位是 1，找 0</span><br>                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) &#123;<br>                    res = (res &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到 0 了，这一位可以直接置为 1</span><br>                    cur = cur.left;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 没找到</span><br>                    res = res &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 没有找到 0 ，这一位就只能是 0 了</span><br>                    cur = cur.right;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    Trie left = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 记录该位为 0</span><br>    Trie right = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 记录该位为 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>看到这里，如果你觉得你懂了，跃跃欲试，就来试试<a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">LC1707</a>吧，和上面那个如出一辙，都是寻找<strong>最大异或值</strong>，只是在此基础之上加了点限制。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章也是入门了一下前缀树，其实它没有那么难理解，关键就在于如何应用它，前缀该如何定义？把到每一个结点的过程可以看作是一个状态的转移，那么在每一步又有多少种状态可以转移？像在单词的应用中，每一步有 26 个方向可以转移，即 26 个字母，而在二进制数中，每一步仅有两个方向可以转移，即 0 和 1。思考清楚这些，相信会对前缀树有更好的理解并且可以有更高级的应用。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;前缀树是什么呢，先看一段维基百科上对它的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要理解它首先要知道我们用这个东西的&lt;strong&gt;目的&lt;/strong&gt;是什么，我举一个最直观的例子，比如要查询某个单词，很多搜索框都有&lt;strong&gt;搜索提示&lt;/strong&gt;。你想查询“Hello”这个单词，当你输入“Hel”甚至输入“H”时可能提示框就已经出现了“Hello”这个单词。前缀树最常用的应用就在这里，即&lt;strong&gt;通过某一前缀去查到该前缀底下对应的有什么单词&lt;/strong&gt;。有的人可能会问“那我直接把所有单词存在一个数组或者List，遍历一遍不是也能查到吗！”，确实，但你不觉得这样在查找某个单词的时候其实花了很多时间访问到了很多无用数据吗，十分的浪费时间。使用前缀树可以将查找某个单词的时间复杂度降到 **O(logn)**。&lt;/p&gt;
&lt;p&gt;简单来说，首先它是一棵&lt;strong&gt;树&lt;/strong&gt;，其次树中的&lt;strong&gt;每个结点&lt;/strong&gt;都是&lt;strong&gt;当前的前缀&lt;/strong&gt;，这样便于我们用更少的时间去查找某个元素。我再画一张图加深一下理解，为了图的简洁，假设当前单词库里就三个单词，“hi”、“me”和“min”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/trie/Trie_ex1.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://congregalis.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="前缀树" scheme="https://congregalis.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
    <category term="字典树" scheme="https://congregalis.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
    <category term="Trie" scheme="https://congregalis.github.io/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>使用Agora SDK与Flutter进行音视频开发</title>
    <link href="https://congregalis.github.io/2021/05/12/%E4%BD%BF%E7%94%A8Agora-SDK%E4%B8%8EFlutter%E8%BF%9B%E8%A1%8C%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    <id>https://congregalis.github.io/2021/05/12/%E4%BD%BF%E7%94%A8Agora-SDK%E4%B8%8EFlutter%E8%BF%9B%E8%A1%8C%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/</id>
    <published>2021-05-12T12:19:54.000Z</published>
    <updated>2021-05-12T17:41:44.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>自疫情以来，音视频开发的地位越来越高，开会、上课、远程办公甚至直播，许许多多的场景都离不开音视频开发。</p><p>这篇文章就记录一下我在flutter上进行音视频开发（使用Agora SDK）的入门经验。</p><span id="more"></span><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>首先，你需要</p><ul><li>Flutter SDK</li></ul><p>如果你要开发安卓应用，那么你需要</p><ul><li>Android SDK</li><li>Android Studio 或者 VSCode</li></ul><p>如果你要开发IOS应用，那么你需要</p><ul><li>Xcode</li></ul><p>由于要使用到 Agora SDK ，所以还需要</p><ul><li><a href="https://pub.dev/packages/agora_rtc_engine">agora_rtc_engine</a> （这个不用下载，在后面步骤中会通过flutter的依赖导入自动下载）</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>这一节就来细分具体的步骤。</p><h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1. 导入依赖"></a>1. 导入依赖</h4><p>在 <code>pubspec.yaml</code> 中添加依赖项</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"># 依赖项<br>dependencies:<br>  flutter:<br>    sdk: flutter<br><br><br>  # The following adds the Cupertino Icons font to your application.<br>  # Use <span class="hljs-keyword">with</span> the CupertinoIcons <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">for</span> <span class="hljs-title">iOS</span> <span class="hljs-title">style</span> <span class="hljs-title">icons</span>.</span><br><span class="hljs-class">  <span class="hljs-title">cupertino_icons</span>: ^0.1.3</span><br><span class="hljs-class"></span><br><span class="hljs-class">  # 以下是新加的</span><br><span class="hljs-class"></span><br><span class="hljs-class">  # <span class="hljs-title">Agora</span> <span class="hljs-title">Flutter</span> <span class="hljs-title">SDK</span> 依赖项，目前最新版本为3.3.3</span><br><span class="hljs-class">  <span class="hljs-title">agora_rtc_engine</span>: ^3.3.3</span><br><span class="hljs-class">  #  权限处理插件依赖项</span><br><span class="hljs-class">  <span class="hljs-title">permission_handler</span>: ^3.0.0</span><br></code></pre></td></tr></table></figure><p>然后运行 <code>flutter pub get</code> 。</p><p>以下的代码可能会需要像这样导入包</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:agora_rtc_engine/rtc_engine.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:agora_rtc_engine/rtc_local_view.dart&#x27;</span> <span class="hljs-keyword">as</span> RtcLocalView;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:agora_rtc_engine/rtc_remote_view.dart&#x27;</span> <span class="hljs-keyword">as</span> RtcRemoteView;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:permission_handler/permission_handler.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-定义-App-ID-和-Token"><a href="#2-定义-App-ID-和-Token" class="headerlink" title="2. 定义 App ID 和 Token"></a>2. 定义 App ID 和 Token</h4><p>在某个全局文件中可以预先定义好这些配置，这些配置要在 <a href="https://console.agora.io/">Agora 控制台</a>得到。<br>Token实际上是要动态获取的，这里以控制台中提供的临时使用的Token做一个测试。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> APP_ID = <span class="hljs-string">&#x27;&lt;Your App ID&gt;&#x27;</span>;<br><span class="hljs-keyword">const</span> Token = <span class="hljs-string">&#x27;&lt;Your Token&gt;&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/flutter-agora/token.png" alt="控制台中获取 APP_ID 与 Token"></p><h4 id="3-创建-RTC-客户端实例"><a href="#3-创建-RTC-客户端实例" class="headerlink" title="3. 创建 RTC 客户端实例"></a>3. 创建 RTC 客户端实例</h4><p>创建 RTC 客户端实例可以在应用状态类 <code>State</code> 中的 <code>initState</code> 中创建，同时也要注意如果退出当前页面也要在相应退出方法中销毁 RTC 客户端实例。</p><p>初始化时将其包装为一个方法 <code>_initAgoraRtcEngine()</code> 如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-keyword">void</span>&gt; _initAgoraRtcEngine() <span class="hljs-keyword">async</span> &#123;<br>  _engine = <span class="hljs-keyword">await</span> RtcEngine.create(APP_ID);<br>  <span class="hljs-keyword">await</span> _engine.enableVideo();<br>  <span class="hljs-keyword">await</span> _engine.setChannelProfile(ChannelProfile.LiveBroadcasting);<br>  <span class="hljs-keyword">await</span> _engine.setClientRole(ClientRole.Broadcaster);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>_engine</code> 为成员内部变量，在类中可以先定义一下 <code>RtcEngine _engine;</code></p><h4 id="4-定义事件处理逻辑"><a href="#4-定义事件处理逻辑" class="headerlink" title="4. 定义事件处理逻辑"></a>4. 定义事件处理逻辑</h4><p>Agora 的 Engine 提供了大量的事件回调，基本每一个音视频开发都会用到，所以这里也有必要为它加上事件处理，这里同一将其包装为一个方法作为展示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _addAgoraEventHandlers() &#123;<br>    _engine.setEventHandler(RtcEngineEventHandler(error: (code) &#123;<br>        <span class="hljs-comment">// 发生错误回调</span><br>        setState(() &#123;<br>            <span class="hljs-keyword">final</span> info = <span class="hljs-string">&#x27;onError: <span class="hljs-subst">$code</span>&#x27;</span>;<br>            _infos.add(info);<br>        &#125;);<br>    &#125;, joinChannelSuccess: (channel, uid, elapsed) &#123;<br>        <span class="hljs-comment">// 加入频道成功回调</span><br>        setState(() &#123;<br>            <span class="hljs-keyword">final</span> info = <span class="hljs-string">&#x27;onJoinChannel: <span class="hljs-subst">$channel</span>, uid: <span class="hljs-subst">$uid</span>&#x27;</span>;<br>            _infos.add(info);<br>        &#125;);<br>    &#125;, leaveChannel: (stats) &#123;<br>        <span class="hljs-comment">// 离开频道回调</span><br>        setState(() &#123;<br>            _infos.add(<span class="hljs-string">&#x27;onLeaveChannel&#x27;</span>);<br>            _remoteUId = <span class="hljs-keyword">null</span>;<br>        &#125;);<br>    &#125;, userJoined: (uid, elapsed) &#123;<br>        <span class="hljs-comment">// 用户加入回调</span><br>        setState(() &#123;<br>            <span class="hljs-keyword">final</span> info = <span class="hljs-string">&#x27;userJoined: <span class="hljs-subst">$uid</span>&#x27;</span>;<br>            _infos.add(info);<br>            _remoteUId = $uid;<br>        &#125;);<br>    &#125;, userOffline: (uid, elapsed) &#123;<br>        <span class="hljs-comment">// 用户离线回调</span><br>        setState(() &#123;<br>            <span class="hljs-keyword">final</span> info = <span class="hljs-string">&#x27;userOffline: <span class="hljs-subst">$uid</span>&#x27;</span>;<br>            _infos.add(info);<br>            _remoteUId = <span class="hljs-keyword">null</span>;<br>        &#125;);<br>    &#125;, firstRemoteVideoFrame: (uid, width, height, elapsed) &#123;<br>        <span class="hljs-comment">// 已显示远端视频首帧回调</span><br>        setState(() &#123;<br>            <span class="hljs-keyword">final</span> info = <span class="hljs-string">&#x27;firstRemoteVideo: <span class="hljs-subst">$uid</span> <span class="hljs-subst">$&#123;width&#125;</span>x <span class="hljs-subst">$height</span>&#x27;</span>;<br>            _infos.add(info);<br>        &#125;);<br>    &#125;));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了 5 个回调事件（发生错误回调、加入频道成功回调、离开频道回调、用户加入回调、用户离线回调、已显示远端视频首帧回调），当然 Agora 提供的远不止这些，具体可以看<a href="https://docs.agora.io/cn/Video/API%20Reference/flutter/rtc_engine/RtcEngineEventHandler-class.html">这里</a>。</p><p><code>_infos</code>  是我定义的一个数组，用来保存所有消息。<code>_remoteUId</code> 是 int 类型，用来保存远程视频用户的 id。</p><p>然后在 父类 <code>State</code> 的 <code>initState()</code> 方法中加入刚刚定义的那些东西就完成初始化了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> initState() &#123;<br>  <span class="hljs-keyword">super</span>.initState();<br>  <span class="hljs-comment">// initialize agora sdk</span><br>  initialize();<br>&#125;<br><br>Future&lt;<span class="hljs-keyword">void</span>&gt; initialize() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">if</span> (APP_ID.isEmpty) &#123;<br>    setState(() &#123;<br>      _infoStrings.add(<span class="hljs-string">&#x27;缺少APP_ID&#x27;</span>,);<br>      _infoStrings.add(<span class="hljs-string">&#x27;Agora Engine 没有成功启动&#x27;</span>);<br>    &#125;);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">await</span> _initAgoraRtcEngine();<br>  _addAgoraEventHandlers();<br>  <span class="hljs-keyword">await</span> _engine.enableWebSdkInteroperability(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 打开与 Web SDK 的互通（仅在直播下适用）</span><br>  VideoEncoderConfiguration configuration = VideoEncoderConfiguration();<br>  configuration.dimensions = VideoDimensions(<span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>); <span class="hljs-comment">// 设置分辨率</span><br>  <span class="hljs-keyword">await</span> _engine.setVideoEncoderConfiguration(configuration);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-开启视频并加入频道"><a href="#5-开启视频并加入频道" class="headerlink" title="5. 开启视频并加入频道"></a>5. 开启视频并加入频道</h4><p>这个很简单，调用 <code>RtcEngine</code> 的 <code>joinChannel()</code> 即可。</p><p><code>_engine.joinChannel(Token, widget.channelName, null, 0);</code><br>该方法有四个参数:</p><ul><li>token : 房间对应的Token，生产环境中需<a href="https://docs.agora.io/cn/Agora%20Platform/token?platform=All%20Platforms#generatetoken">动态获取</a></li><li>channelName : 房间（频道）名</li><li>optionalInfo : （非必选，不用时设为 null 即可）开发者需加入的附加信息</li><li>optionalUid : （非必选，不用时设为 0 即可）用户Id，若不指定（即 0）则由 SDK 自动分配，但 SDK 不对此值进行维护，所以最好在服务端分配。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> initState() &#123;<br>  <span class="hljs-keyword">super</span>.initState();<br>  <span class="hljs-comment">// initialize agora sdk</span><br>  initialize();<br>&#125;<br><br>Future&lt;<span class="hljs-keyword">void</span>&gt; initialize() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">if</span> (APP_ID.isEmpty) &#123;<br>    setState(() &#123;<br>      _infoStrings.add(<span class="hljs-string">&#x27;缺少APP_ID&#x27;</span>,);<br>      _infoStrings.add(<span class="hljs-string">&#x27;Agora Engine 没有成功启动&#x27;</span>);<br>    &#125;);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">await</span> _initAgoraRtcEngine();<br>  _addAgoraEventHandlers();<br>  <span class="hljs-keyword">await</span> _engine.enableWebSdkInteroperability(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 打开与 Web SDK 的互通（仅在直播下适用）</span><br>  VideoEncoderConfiguration configuration = VideoEncoderConfiguration();<br>  configuration.dimensions = VideoDimensions(<span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>); <span class="hljs-comment">// 设置分辨率</span><br>  <span class="hljs-keyword">await</span> _engine.setVideoEncoderConfiguration(configuration);<br><br>  <span class="hljs-comment">// 以下为新加代码</span><br><br>  <span class="hljs-keyword">await</span> _engine.joinChannel(Token, widget.channelName, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-构建-UI-，显示视频画面"><a href="#6-构建-UI-，显示视频画面" class="headerlink" title="6. 构建 UI ，显示视频画面"></a>6. 构建 UI ，显示视频画面</h4><p>Agora 已经为我们封装好组件，即</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:agora_rtc_engine/rtc_local_view.dart&#x27;</span> <span class="hljs-keyword">as</span> RtcLocalView;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:agora_rtc_engine/rtc_remote_view.dart&#x27;</span> <span class="hljs-keyword">as</span> RtcRemoteView;<br></code></pre></td></tr></table></figure><p>使用 <code>RtcLocalView.SurfaceView()</code> 则是本地视频，调用本地摄像头；<br>使用 <code>RtcRemoteView.SurfaceView(uid: uid)</code> 则是对应 uid 的远程用户视频。<br>可以自行在外包装 Container, Center 等进行布局设置。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>稍后补上，今天先不开mac了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Agora 提供的插件来进行开发还是很简单的，总结一下大致步骤：</p><ol><li>创建客户端实例 <code>RtcEngine</code> ，并做一些配置（使用 <code>RtcEngineConfig</code> ）；</li><li>定义事件处理逻辑 <code>RtcEngineEventHandler</code> ，处理一些事件回调；</li><li>开启视频，构建UI <code>RtcRemoteView.SurfaceView(uid: _remoteUid)</code> 。</li></ol><p>音视频开发肯定远不止如此，这只是一个入门级的示例，后续有机会再进一步探索这个领域。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.agora.io/cn/Video/landing-page?platform=Flutter">https://docs.agora.io/cn/Video/landing-page?platform=Flutter</a></li><li><a href="https://docs.agora.io/cn/Video/API%20Reference/flutter/index.html">https://docs.agora.io/cn/Video/API%20Reference/flutter/index.html</a></li><li><a href="https://github.com/AgoraIO/Agora-Flutter-SDK/tree/master/example">官方示例源码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;自疫情以来，音视频开发的地位越来越高，开会、上课、远程办公甚至直播，许许多多的场景都离不开音视频开发。&lt;/p&gt;
&lt;p&gt;这篇文章就记录一下我在flutter上进行音视频开发（使用Agora SDK）的入门经验。&lt;/p&gt;</summary>
    
    
    
    <category term="Flutter" scheme="https://congregalis.github.io/categories/Flutter/"/>
    
    
    <category term="移动开发" scheme="https://congregalis.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="flutter" scheme="https://congregalis.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>使用SpringBoot的线程池处理异步任务</title>
    <link href="https://congregalis.github.io/2021/05/07/%E4%BD%BF%E7%94%A8SpringBoot%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>https://congregalis.github.io/2021/05/07/%E4%BD%BF%E7%94%A8SpringBoot%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</id>
    <published>2021-05-07T13:34:47.000Z</published>
    <updated>2021-05-08T13:17:06.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近在做项目时了解了最好不要直接使用 <code>new Thread(...).start()</code> ，用线程池来隐式的维护所有线程，具体为什么可以看<a href="https://congregalis.gitee.io/2021/04/29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E5%81%9C%E6%AD%A2%E4%BD%A0%E7%9A%84new-Thread/">这篇文章</a>。</p><p>其实 SpringBoot 已经为我们创建并配置好了这个东西，这里就来学习一下如何来使用 SpringBoot 为我们设置的线程池。</p><span id="more"></span><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h3><p>首先我们需要创建一个<strong>配置类</strong>来让 SpringBoot 加载，并且在里面设置一些自己需要的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ExecutorConfig.class);<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;async.executor.thread.core_pool_size&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> corePoolSize;<br>    <span class="hljs-meta">@Value(&quot;$&#123;async.executor.thread.max_pool_size&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxPoolSize;<br>    <span class="hljs-meta">@Value(&quot;$&#123;async.executor.thread.queue_capacity&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> queueCapacity;<br>    <span class="hljs-meta">@Value(&quot;$&#123;async.executor.thread.keep_alive_seconds&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> keepAliveSeconds;<br>    <span class="hljs-meta">@Value(&quot;$&#123;async.executor.thread.name.prefix&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String namePrefix;<br><br>    <span class="hljs-meta">@Bean(name = &quot;asyncServiceExecutor&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">asyncServiceExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;开启SpringBoot的线程池！&quot;</span>);<br><br>        ThreadPoolTaskExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolTaskExecutor();<br><br>        <span class="hljs-comment">// 设置核心线程数</span><br>        executor.setCorePoolSize(corePoolSize);<br>        <span class="hljs-comment">// 设置最大线程数</span><br>        executor.setMaxPoolSize(maxPoolSize);<br>        <span class="hljs-comment">// 设置缓冲队列大小</span><br>        executor.setQueueCapacity(queueCapacity);<br>        <span class="hljs-comment">// 设置线程的最大空闲时间</span><br>        executor.setKeepAliveSeconds(keepAliveSeconds);<br>        <span class="hljs-comment">// 设置线程名字的前缀</span><br>        executor.setThreadNamePrefix(namePrefix);<br>        <span class="hljs-comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span><br>        <span class="hljs-comment">// CALLER_RUNS：在添加到线程池失败时会由主线程自己来执行这个任务</span><br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<br><br>        <span class="hljs-comment">// 线程池初始化</span><br>        executor.initialize();<br><br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，</p><ul><li><code>@Configuration</code> 的作用是表明这是一个配置类。</li><li><code>@EnableAsync</code> 的作用是启用 SpringBoot 的异步执行</li></ul><p>其次，关于线程池的设置有</p><ul><li><code>corePoolSize</code>: <strong>核心线程数</strong>，当向线程池提交一个任务时<strong>池里的线程数小于核心线程数</strong>，那么它会创建一个线程来执行这个任务，一直<strong>直到池内的线程数等于核心线程数</strong></li><li><code>maxPoolSize</code>: <strong>最大线程数</strong>，线程池中允许的最大线程数量。关于这两个数量的区别我会在下面解释</li><li><code>queueCapacity</code>: <strong>缓冲队列大小</strong>，用来保存<strong>阻塞</strong>的<strong>任务队列</strong>（注意这里的队列放的是<strong>任务</strong>而不是线程）</li><li><code>keepAliveSeconds</code>: <strong>允许线程存活时间（空闲状态下）</strong>，单位为秒，默认60s</li><li><code>namePrefix</code>: <strong>线程名前缀</strong></li><li><code>RejectedExecutionHandler</code>: <strong>拒绝策略</strong>，当线程池达到最大线程数时，如何处理新任务。线程池为我们提供的策略有<ul><li>AbortPolicy：默认策略。直接<strong>抛出 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RejectedExecutionException.html">RejectedExecutionException</a></strong></li><li>DiscardPolicy：<strong>直接丢弃掉被拒绝的任务</strong>，且不会抛出任何异常</li><li>DiscardOldestPolicy：<strong>丢弃掉队列中的队头元素</strong>（也就是最早在队列里的任务），然后重新执行 <strong>提交该任务</strong> 的操作</li><li>CallerRunsPolicy：<strong>由主线程自己来执行这个任务</strong>，该机制将减慢新任务的提交</li></ul></li></ul><p>关于 <code>corePoolSize</code> 与 <code>maxPoolSize</code> 的区别也是困惑了我很久，<a href="https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ThreadPoolExecutor.html">官方文档上的解释</a>说的很清楚。我的理解如下：</p><p>这个线程池其实是有点“弹性的”。当向线程池提交任务时：</p><ul><li><p>若 <strong><code>当前运行的线程数 &lt; corePoolSize</code></strong></p><p>  则 <strong>即使其它的工作线程处于空闲状态</strong>，线程池也会创建一个新线程来执行任务</p></li><li><p>若 <strong><code>corePoolSize &lt; 当前运行的线程数 &lt; maxPoolSize</code></strong></p><ul><li><p>若 <strong>队列已满</strong></p><p>  则 创建新线程来执行任务</p></li><li><p>若 <strong>队列未满</strong></p><p>  则 加入队列中</p></li></ul></li><li><p>若 <strong><code>当前运行的线程数 &gt; maxPoolSize</code></strong></p><ul><li><p>若 <strong>队列已满</strong></p><p>  则 拒绝任务</p></li><li><p>若 <strong>队列未满</strong></p><p>  则 加入队列中</p></li></ul></li></ul><p>所以当想要创建固定大小的线程池时，将 <code>corePoolSize</code> 和 <code>maxPoolSize</code> 设置成一样就行了。</p><p>最后，别忘了给方法加上 <strong><code>@Bean</code></strong> 注解，否则 SpringBoot 不会加载。</p><p>这里因为我加了 <code>@Value</code> 注解，可以在 <code>application.properties</code> 中配置相关数据，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"># 配置核心线程数<br>async.executor.thread.core_pool_size = <span class="hljs-number">5</span><br># 配置最大线程数<br>async.executor.thread.max_pool_size = <span class="hljs-number">5</span><br># 配置队列大小<br>async.executor.thread.queue_capacity = <span class="hljs-number">999</span><br># 配置线程池中的线程的名称前缀<br>async.executor.thread.name.prefix = test-async-<br># 配置线程最大空闲时间<br>async.executor.thread.keep_alive_seconds = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><h3 id="在具体的方法中使用"><a href="#在具体的方法中使用" class="headerlink" title="在具体的方法中使用"></a>在具体的方法中使用</h3><p>配置完上面那些使用起来就轻松了，只需在业务方法前加上 <strong><code>@Async</code></strong> 注解，它就会异步执行了。</p><p>如<strong>在 Service 中添加如下方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async(&quot;asyncServiceExecutor&quot;)</span><br><span class="hljs-comment">// 注：@Async所修饰的函数不能定义为static类型，这样异步调用不会生效</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;任务开始！&quot;</span>);<br><br>    System.out.println(<span class="hljs-string">&quot;异步执行某耗时的事...&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;如休眠5秒&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">5000</span>);<br><br>    logger.info(<span class="hljs-string">&quot;任务结束！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后<strong>在 Controller 里调用一下这个方法</strong>，在网页上连续发送请求做一个测试。<br>我这里连续发起了5次请求，可以看到这5个任务确实是成功地异步执行了。<br><img src="/img/20210508thread/res1.png"></p><p>我设置的线程池大小为 5，所以<strong>当超过 5 个任务被提交时，会放入阻塞队列中</strong>。<br><img src="/img/20210508thread/res2.png"></p><p><strong>到这里，基本的异步执行任务就实现了。</strong></p><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>虽然它提供给我们的线程池已经很强大了，但是有时候我们还需要一些<strong>额外信息</strong>，比如说我们想知道这个线程池已经执行了多少任务了、当前有多少线程在运行、阻塞队列里还有多少任务等等。那么这个时候我们就可以自定义我们的线程池。</p><p>自定义很简单，自己写一个类继承 Spring 提供的 <code>ThreadPoolTaskExecutor</code>，在此之上做修改就好了。如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisibleThreadPoolTaskExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolTaskExecutor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(VisibleThreadPoolTaskExecutor.class);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;<br>        ThreadPoolExecutor executor = getThreadPoolExecutor();<br><br>        <span class="hljs-keyword">if</span> (executor == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br><br>        String info = <span class="hljs-string">&quot;线程池&quot;</span> + <span class="hljs-keyword">this</span>.getThreadNamePrefix() +<br>                <span class="hljs-string">&quot;中，总任务数为 &quot;</span> + executor.getTaskCount() +<br>                <span class="hljs-string">&quot; ，已处理完的任务数为 &quot;</span> + executor.getCompletedTaskCount() +<br>                <span class="hljs-string">&quot; ，目前正在处理的任务数为 &quot;</span> + executor.getActiveCount() +<br>                <span class="hljs-string">&quot; ，缓冲队列中任务数为 &quot;</span> + executor.getQueue().size();<br><br>        logger.info(info);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>        info();<br>        <span class="hljs-keyword">super</span>.execute(task);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task, <span class="hljs-keyword">long</span> startTimeout)</span> </span>&#123;<br>        info();<br>        <span class="hljs-keyword">super</span>.execute(task, startTimeout);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>        info();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.submit(task);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span>&#123;<br>        info();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.submit(task);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ListenableFuture&lt;?&gt; submitListenable(Runnable task) &#123;<br>        info();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.submitListenable(task);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">ListenableFuture&lt;T&gt; <span class="hljs-title">submitListenable</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> </span>&#123;<br>        info();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.submitListenable(task);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在我们的配置类 <code>ExecutorConfig</code> 中将 </p><p><code>ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();</code><br>改为<br><code>ThreadPoolTaskExecutor executor = new VisibleThreadPoolTaskExecutor();</code>，<br>也就是使用我们自己定义的线程池，然后会在相应的任务执行（<code>execute()</code>）、任务提交（<code>submit()</code>）时打印我们需要的信息了。<br><img src="/img/20210508thread/res3.png" alt="打印结果，在此之前已处理了5个任务"></p><h3 id="查询线程池信息"><a href="#查询线程池信息" class="headerlink" title="查询线程池信息"></a>查询线程池信息</h3><p>上面自定义线程池后想查询信息<strong>只能在线程池中的方法查询</strong>，那如果我想在任意地方查询线程池的信息呢？那也是可以的，而且非常简单。我这里写一个接口来查询线程池的任务信息以做示例。</p><p>首先修改一下线程池里的 <code>Info()</code> 方法，让它返回我们需要的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;<br>    ThreadPoolExecutor executor = getThreadPoolExecutor();<br>    <span class="hljs-keyword">if</span> (executor == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池不存在&quot;</span>;<br><br>    String info = <span class="hljs-string">&quot;线程池&quot;</span> + <span class="hljs-keyword">this</span>.getThreadNamePrefix() +<br>            <span class="hljs-string">&quot;中，总任务数为 &quot;</span> + executor.getTaskCount() +<br>            <span class="hljs-string">&quot; ，已处理完的任务数为 &quot;</span> + executor.getCompletedTaskCount() +<br>            <span class="hljs-string">&quot; ，目前正在处理的任务数为 &quot;</span> + executor.getActiveCount() +<br>            <span class="hljs-string">&quot; ，缓冲队列中任务数为 &quot;</span> + executor.getQueue().size();<br><br>    logger.info(info);<br><br>    <span class="hljs-keyword">return</span> info;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改一下配置类 <code>ExecutorConfig</code> 里注册线程池的方法，让它<strong>注册的是我们自定义的线程池类型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;asyncServiceExecutor&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> VisibleThreadPoolTaskExecutor <span class="hljs-title">asyncServiceExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    logger.info(<span class="hljs-string">&quot;开启SpringBoot的线程池！&quot;</span>);<br><br>    <span class="hljs-comment">// 修改这里，要返回我们自己定义的类 VisibleThreadPoolTaskExecutor</span><br>    VisibleThreadPoolTaskExecutor executor = <span class="hljs-keyword">new</span> VisibleThreadPoolTaskExecutor();<br><span class="hljs-comment">//        ThreadPoolTaskExecutor executor = new VisibleThreadPoolTaskExecutor();</span><br><br>    <span class="hljs-comment">// 设置核心线程数</span><br>    executor.setCorePoolSize(corePoolSize);<br>    <span class="hljs-comment">// 设置最大线程数</span><br>    executor.setMaxPoolSize(maxPoolSize);<br>    <span class="hljs-comment">// 设置缓冲队列大小</span><br>    executor.setQueueCapacity(queueCapacity);<br>    <span class="hljs-comment">// 设置线程的最大空闲时间</span><br>    executor.setKeepAliveSeconds(keepAliveSeconds);<br>    <span class="hljs-comment">// 设置线程名字的前缀</span><br>    executor.setThreadNamePrefix(namePrefix);<br>    <span class="hljs-comment">// 设置拒绝策略：当线程池达到最大线程数时，如何处理新任务</span><br>    <span class="hljs-comment">// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</span><br>    executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<br><br>    <span class="hljs-comment">// 线程池初始化</span><br>    executor.initialize();<br><br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure><p>再在我们需要信息的地方<strong>自动注入</strong>这个线程池，然后调用一下 <code>info()</code> 方法就能得到信息了，我这里以在 Service 层中获取信息为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(DemoService.class);<br><br>    <span class="hljs-comment">// 别忘了这里要用 SpringBoot 的自动注入</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> VisibleThreadPoolTaskExecutor executor;<br><br>    <span class="hljs-comment">// @SneakyThrows 这个注解是Lombok带的，我为了代码简洁使用的。你也可以使用 try catch 的方法。</span><br>    <span class="hljs-meta">@SneakyThrows</span> <br>    <span class="hljs-meta">@Async(&quot;asyncServiceExecutor&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncTest</span><span class="hljs-params">()</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;任务开始！&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;异步执行某耗时的事...&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;如休眠5秒&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br><br>        logger.info(<span class="hljs-string">&quot;任务结束！&quot;</span>);<br><br>        <span class="hljs-comment">// 你甚至可以在任务结束时再打印一下线程池信息</span><br>        executor.info();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getExecutorInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> executor.info();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在 Controller 层中调用一下，就大功告成了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DemoService demoService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/async&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">async</span><span class="hljs-params">()</span> </span>&#123;<br>        demoService.asyncTest();<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/info&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> demoService.getExecutorInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>来看一下测试的结果吧，我这里调用 /async 一口气开启了 15 个任务，然后在不同时间使用 /info 来看看信息。</p><p><img src="/img/20210508thread/res4.png" alt="刚开始时的结果"></p><p><img src="/img/20210508thread/res5.png" alt="一口气提交了15个任务后的中间结果"></p><p><img src="/img/20210508thread/res6.png" alt="所有任务都执行完了的最终结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇到这里就结束了，篇幅略长。总结一下，要想在SpringBoot中使用它提供的线程池其实很简单，只要两步：</p><ol><li><strong>注册线程池</strong>（使用 @Bean 来注册），设置一些自己想要的<strong>参数</strong>；</li><li>在想要异步调用的方法上<strong>加上 @Async 注解</strong>。</li></ol><p>当然你也可以不使用 @Async 注解，直接在想开线程的地方<strong>自动注入</strong>你注册的线程池，然后像普通线程池一样使用就行了。</p><p>其实关于这一方面的知识也讲得并不够详尽，比如线程池里还有哪些方法、SpringBoot是如何为我们弄得这么方便的等等，还需要多多补充知识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/1878806/what-is-the-difference-between-corepoolsize-and-maxpoolsize-in-the-spring-thread">https://stackoverflow.com/questions/1878806/what-is-the-difference-between-corepoolsize-and-maxpoolsize-in-the-spring-thread</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html</a></li><li><a href="https://blog.csdn.net/m0_37701381/article/details/81072774?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">https://blog.csdn.net/m0_37701381/article/details/81072774?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;最近在做项目时了解了最好不要直接使用 &lt;code&gt;new Thread(...).start()&lt;/code&gt; ，用线程池来隐式的维护所有线程，具体为什么可以看&lt;a href=&quot;https://congregalis.gitee.io/2021/04/29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E5%81%9C%E6%AD%A2%E4%BD%A0%E7%9A%84new-Thread/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其实 SpringBoot 已经为我们创建并配置好了这个东西，这里就来学习一下如何来使用 SpringBoot 为我们设置的线程池。&lt;/p&gt;</summary>
    
    
    
    <category term="技术小技巧" scheme="https://congregalis.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="Java" scheme="https://congregalis.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://congregalis.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>位运算研究——只出现一次的数字2</title>
    <link href="https://congregalis.github.io/2021/05/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%A0%94%E7%A9%B6%E2%80%94%E2%80%94%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%972/"/>
    <id>https://congregalis.github.io/2021/05/07/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%A0%94%E7%A9%B6%E2%80%94%E2%80%94%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%972/</id>
    <published>2021-05-07T07:41:58.000Z</published>
    <updated>2021-05-11T16:20:32.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这一篇接着<a href="https://congregalis.gitee.io/2021/05/04/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/">上一篇</a>来说说位运算，首先看题目<a href="https://leetcode-cn.com/problems/single-number-ii/">LC137</a>。</p><p><img src="/img/bitcal2/problem.png" alt="只出现一次的数字 II"></p><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>这个题与上一题的区别仅在于将除答案外的元素出现次数从两次变成了<strong>三次</strong>，所以直接使用哈希表也是可以做的，但我们这里要探究<strong>位运算</strong>的解法。</p><span id="more"></span><p>在上一题中，我们根据位运算的一些性质可以得出结论：将所有元素都异或起来，最终答案就是只出现一次的数字。但是在这里情况不一样，元素的出现次数是<strong>三次</strong>，<strong>三个一样的数异或在一起还是它本身</strong>，所以上一种方法肯定不管用了。</p><p>对于这种题，实在思考不出来我喜欢写几个举例子来找找规律，结果还真给我找着了。我这里以 <code>[2,2,3,2]</code> 为例给大家看看我找到的规律，首先把它们都转为二进制（<strong>在位运算中，将数都转换为二进制再来思考解法是很重要的</strong>），然后以一个数组（也就是图中的 <code>cnt[]</code>）来记录每一位 <strong>1</strong> 出现的次数。既然每个元素都只出现3次，那我把这个 <strong>1</strong> 出现的次数 <strong>模 3</strong> 剩下的岂不是就是那个<strong>没出现3次的数字</strong>，也就是答案了吗？看看下图可能会更容易理解。<br><img src="/img/bitcal2/solve.png" alt="[2,2,3,2]"></p><p>想到这里，代码也就不是什么问题了。实现细节上，cnt数组只需要大小为32就行了，因为题目中给的数字大小范围是在32位以内的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>]; <span class="hljs-comment">// 维护一个记录 **二进制下每一位上1出现次数** 的数组</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>                <span class="hljs-keyword">if</span> (((num &gt;&gt; i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>                    cnt[i]++;<br><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>            <span class="hljs-keyword">if</span> ((cnt[i] % <span class="hljs-number">3</span> &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>                ans += <span class="hljs-number">1</span> &lt;&lt; i;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这道题的解法也是非常巧妙，关键就在于<strong>把数都转为二进制</strong>，再在二进制下来思考如何找到解，画一画图找一找规律都是很有必要的。</p><p>这道题把这个元素出现次数改成4、5、6等等次数都是一样的做法，只要在每一位上去<strong>对相应的数取余</strong>就可以了，是不是很简单呢！当然在次数是偶数的时候可以使用上一篇的做法，毕竟两两异或后就抵消掉了（为0）。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;这一篇接着&lt;a href=&quot;https://congregalis.gitee.io/2021/05/04/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/&quot;&gt;上一篇&lt;/a&gt;来说说位运算，首先看题目&lt;a href=&quot;https://leetcode-cn.com/problems/single-number-ii/&quot;&gt;LC137&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/bitcal2/problem.png&quot; alt=&quot;只出现一次的数字 II&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;解&quot;&gt;&lt;a href=&quot;#解&quot; class=&quot;headerlink&quot; title=&quot;解&quot;&gt;&lt;/a&gt;解&lt;/h2&gt;&lt;p&gt;这个题与上一题的区别仅在于将除答案外的元素出现次数从两次变成了&lt;strong&gt;三次&lt;/strong&gt;，所以直接使用哈希表也是可以做的，但我们这里要探究&lt;strong&gt;位运算&lt;/strong&gt;的解法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://congregalis.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://congregalis.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>位运算初探——只出现一次的数字</title>
    <link href="https://congregalis.github.io/2021/05/04/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://congregalis.github.io/2021/05/04/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2021-05-04T15:57:15.000Z</published>
    <updated>2021-05-04T17:20:11.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>位运算，一个高效的东西，同时也是一直使我非常困扰的一大奇妙算法。在这篇文章中我以一个很简单例子对位运算做一个简单的介绍与探究。</p><p>首先来看例子<a href="https://leetcode-cn.com/problems/single-number/">LC136</a>，题目如下：<br><img src="/img/bitcal1/problem1.png" alt="只出现一次的数字"></p><span id="more"></span><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>题目很简单，一下就能读完。读完这个题目第一时间就能想到一个简单的解法：使用一个<strong>哈希表</strong>存储每个数字出现次数，然后最后遍历一遍找只出现一次的数字就行了。</p><p>但是题目中的说明要求算法具有<strong>线性时间复杂度</strong>，并且<strong>不使用额外空间</strong>。看到这个要求，其实除了位运算好像还真没啥别的方法了。那么对于这道题位运算怎么做呢？</p><p>这时候就该去思考如何来使用数字的位信息。我们都知道，每一个数字都能转换成二进制数，转换完后每一位不是0就是1，那么我们如何来运用这个位的信息？针对这道题，你可以看到它有一个特殊的约束：除了某个元素只出现一次以外，其余每个元素均出现<strong>两次</strong>。这个两次就很关键啊，除了答案外<strong>相同的元素有且仅有两次</strong>，这不是和位运算中<strong>异或的归零律</strong>相匹配么？</p><blockquote><p>异或：如果异或的两个数不相同，则异或结果为 1，如果异或的两个数相同，则结果为 0<br>异或的归零率 a $\bigoplus$ a = 0</p></blockquote><p>而且异或运算还存在<strong>交换律</strong>和<strong>结合律</strong>，这也就是说我们把数组中全部的数都异或起来，相同的数只存在两个，那相同的数相碰不就为 <strong>0</strong> 了吗。同时由于** 0 异或任何数结果都是那个数**，那可见最终全部的数异或出的答案就是那个只出现一次的数字了。</p><blockquote><p><strong>0异或任何数结果都是那个数</strong> 出自 异或的恒等率：a $\bigoplus$ 0 = a</p></blockquote><p>为了理解得更加清楚，我把0，1两两异或的结果放在这里，你们可以将数转化为二进制再每一位异或一下看看结果，可以更加深刻的理解这个算法。</p><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">a $\bigoplus$ b</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>到这里，解法就很明确了，这就是位运算了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)<br>            ans ^= num;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码也是非常的简单，位运算十分简洁高效<del>（就是比较难想）</del>。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>这个题目加的限制是<strong>相同的元素有且仅有两次</strong>，那如果不止两次呢？这道<a href="https://leetcode-cn.com/problems/single-number-ii/">LC137</a>可不就来了，它把两次改为了<strong>三次</strong>，同样要求算法具有<strong>线性时间复杂度</strong>，并且<strong>不使用额外空间</strong>，很明显也是要使用位运算的。</p><p>由于这篇文章只是初探，就讲到这里，我会在后面的文章对这道<a href="https://leetcode-cn.com/problems/single-number-ii/">LC137</a>做更进一步的探究！</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>对于要求算法具有<strong>线性时间复杂度</strong>，并且<strong>不使用额外空间</strong>时，不用犹豫，这大概率就是要使用位运算才能解决。这个时候首先要看清有些什么<strong>约束条件</strong>，然后根据不同的位运算以及他们的一些<strong>性质</strong>来思考如何才能有效的利用这些性质。</p><p>对我来说位运算还是挺难的，一起加油攻破这道难关吧！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;位运算，一个高效的东西，同时也是一直使我非常困扰的一大奇妙算法。在这篇文章中我以一个很简单例子对位运算做一个简单的介绍与探究。&lt;/p&gt;
&lt;p&gt;首先来看例子&lt;a href=&quot;https://leetcode-cn.com/problems/single-number/&quot;&gt;LC136&lt;/a&gt;，题目如下：&lt;br&gt;&lt;img src=&quot;/img/bitcal1/problem1.png&quot; alt=&quot;只出现一次的数字&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://congregalis.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://congregalis.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Java线程的正确使用方式——停止你的new Thread</title>
    <link href="https://congregalis.github.io/2021/04/29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E5%81%9C%E6%AD%A2%E4%BD%A0%E7%9A%84new-Thread/"/>
    <id>https://congregalis.github.io/2021/04/29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E5%81%9C%E6%AD%A2%E4%BD%A0%E7%9A%84new-Thread/</id>
    <published>2021-04-29T15:37:00.000Z</published>
    <updated>2021-05-07T13:36:34.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在实验室做相关工作时，一个小伙伴看见项目代码中出现了 <code>new Thread(...)</code> ，破口大骂之。看见这一场景，我默默地删掉了我在另一个地方写的 <code>new Thread(...)</code> 当作无事发生（还好他没看见XD）。</p><p>为了不再犯这种错误，我写下这篇文章来记录一下Java线程究竟该怎么使用（才不会被骂），也是开了一个新坑！</p><span id="more"></span><h2 id="为什么不要用new-Thread"><a href="#为什么不要用new-Thread" class="headerlink" title="为什么不要用new Thread"></a>为什么不要用new Thread</h2><p>首先从我秉持的原则入手，“简洁优雅”。试想如果在一段代码中你需要创建很多线程，那么你就不停地调用 <code>new Thread(...).start()</code> 么？显然这样的代码一点也不简洁，也不优雅。初次之外这样的代码还有很多坏处：</p><ol><li>每次都要新建一个对象，性能差；</li><li>建出来的很多个对象是独立的，缺乏统一的管理。如果在代码中无限新建线程会导致这些线程相互竞争，占用过多的系统资源从而导致死机或者 <strong>oom</strong>；</li><li>缺乏许多功能如定时执行、中断等。</li></ol><p>从这些坏处很容易可以看出解决方法，那就是弄一个监管者来统一的管理这些线程，并将它们存到一个集合（或者类似的数据结构）中，而且还要动态地分配它们的任务。当然Java已经给我们提供好十分健全的东西来使用了，那就是<strong>线程池</strong>！</p><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><p>Java提供了一个工厂类来构造我们需要的线程池，这个工厂类就是 <strong><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html">Executors</a></strong> 。这个类提供了很多方法，我们这里主要讲它提供的4个创建线程池的方法，即</p><ul><li><code>newCachedThreadPool()</code></li><li><code>newFixedThreadPool(int nThreads)</code></li><li><code>newScheduledThreadPool(int corePoolSize)</code></li><li><code>newSingleThreadExecutor()</code></li></ul><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h3><p>这个方法正如它的名字一样，创建缓存线程池。缓存的意思就是这个线程池会<strong>根据需要创建新的线程</strong>，在有新任务的时候会优先使用先前创建出的线程。也就是说线程一旦创建了就一直在这个池子里面了，执行完任务后后续还有任务需要会<strong>重用这个线程</strong>，若是<strong>线程不够用了再去新建线程</strong>。</p><p>以一段代码做个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); <span class="hljs-comment">// 创建缓存线程池</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br><br>    <span class="hljs-comment">// 每次发布任务前等待一段时间，如1s</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    cachedThreadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + index));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子里，我在每次调用线程执行任务之前都等待1秒，这使时间让线程池内的线程执行完上一个任务绰绰有余，所以你会发现输出里都是<strong>同一个线程</strong>在执行任务。<br><img src="/img/javathread1/cachepool1.png" alt="重用线程例子"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); <span class="hljs-comment">// 创建缓存线程池</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br><br>    <span class="hljs-comment">// 每次发布任务前根据奇偶不同等待一段时间，如1s</span><br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    cachedThreadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + index));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中我在每次调用线程执行任务之前根据奇偶不同控制其是否等待，这样就会<strong>在同一时间需要执行2个任务</strong>，所以线程池中按需要多创建了一个线程。你也可以把这个模数改大到3、4、5…来观察线程池是否<strong>按需创建</strong>了新线程。<br><img src="/img/javathread1/cachepool2.png" alt="按需创建新线程例子"></p><p>注意这里的线程池是<strong>无限大的</strong>，我们并没有规定他的大小。（但其实在实际使用时不可能是无限大的，我会在这个系列后面的文章再来探讨这个问题）</p><h3 id="newFixedThreadPool-int-nThreads"><a href="#newFixedThreadPool-int-nThreads" class="headerlink" title="newFixedThreadPool(int nThreads)"></a>newFixedThreadPool(int nThreads)</h3><p>可以看到这个方法中带了一个参数，这个方法创建的线程池是<strong>定长</strong>的，这个参数就是线程池的大小。也就是说，在同一时间执行的线程数量只能是 nThreads 这么多，这个线程池可以有效的控制最大并发数从而防止占用过多资源。超出的线程会放在线程池的一个<strong>队列里等待</strong>其他线程执行完，这个队列也是值得我们去好好研究的，它是一个<strong>无界队列</strong>，我会在这个系列后面的文章探讨它。</p><p>以一段代码做个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>); <span class="hljs-comment">// 创建缓存线程池，大小为3</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    fixedThreadPool.execute(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + index);<br><br>        <span class="hljs-comment">// 模拟执行任务耗时1秒</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子里可以看到我创建了一个大小为3的线程池，也就是说它支持的最大并发线程数是3，运行后发现这些数确实是3个3个为一组输出的。<br><img src="/img/javathread1/fixedpool1.png" alt="定长线程池例子"></p><p>合理的设置定长线程池的大小是一个很重要的事情。</p><h3 id="newScheduledThreadPool-int-corePoolSize"><a href="#newScheduledThreadPool-int-corePoolSize" class="headerlink" title="newScheduledThreadPool(int corePoolSize)"></a>newScheduledThreadPool(int corePoolSize)</h3><p>从 Scheduled 大概可以猜出这个线程池是为了解决上面说过的第3个坏处，也就是缺乏定时执行功能。这个线程池也是<strong>定长</strong>的，参数 corePoolSize 就是线程池的大小，即在空闲状态下要保留在池中的线程数量。</p><p>而要实现调度需要使用这个线程池的 <code>schedule()</code> 方法 （注意这里要把新建线程池的返回类 ExecutorService 改成 <strong>ScheduledExecutorService</strong> 噢）</p><p>以一段代码做个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意！这里把 ExecutorService 改成了 ScheduledExecutorService ，否则没有定时功能</span><br>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">3</span>); <span class="hljs-comment">// 创建缓存线程池</span><br><br><span class="hljs-comment">// 执行任务</span><br>scheduledThreadPool.schedule(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: 我会在3秒后执行。&quot;</span>),<br>        <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><p>这个例子会在3秒后输出结果。当然你可以根据不同的需求设置不同的定时，甚至还能实现定期执行功能，详细可以查看<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html">官方api</a><br><img src="/img/javathread1/scheduledpool1.png" alt="3秒后执行例子"></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h3><p>这个线程池就比较简单了，他是一个<strong>单线程池</strong>，只使用<strong>一个线程</strong>来执行任务。但是它与 <code>newFixedThreadPool(1, threadFactory)</code> 不同，它会<strong>保证创建的这个线程池不会被重新配置为使用其他的线程</strong>，也就是说这个线程池里的线程始终如一。</p><p>以一段代码做个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); <span class="hljs-comment">// 创建单线程池</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    singleThreadExecutor.execute(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + index);<br><br>        <span class="hljs-comment">// 模拟执行任务耗时1秒</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到输出里他只会一秒一秒地打印内容，只有一个线程在执行任务。<br><img src="/img/javathread1/singlethreadpool1.png" alt="单线程池例子"></p><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>如果你运行了我上面的示例，你会发现程序一直都没有结束，这是因为我上面的示例代码并没有关闭线程池。线程池本身提供了两个关闭的方法：</p><ul><li><code>shutdown()</code> : 将线程池状态置成 <code>SHUTDOWN</code>，此时<strong>不再接受新的任务</strong>，<strong>等待线程池中已有任务执行完成后结束</strong>；</li><li><code>shutdownNow()</code> : 将线程池状态置成 <code>SHUTDOWN</code>，将线程池中<strong>所有线程中断</strong>（调用线程的 <code>interrupt()</code> 操作），清空队列，并返回<strong>正在等待执行的任务列表</strong>。</li></ul><p>并且它还提供了查看线程池是否关闭和是否终止的方法，分别为 <code>isShutdown()</code> 和 <code>isTerminated()</code> 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么根据需要使用以上四种线程池就足够应对平时的需求了，别再使用 <code>new Thread(...)</code> 这种方法啦！</p><p>这个系列还会继续更新下去，主要讲解使用Java线程方面的小知识，当然也会稍微探究一下这其中的原理，欢迎你继续 Follow 下去。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在实验室做相关工作时，一个小伙伴看见项目代码中出现了 &lt;code&gt;new Thread(...)&lt;/code&gt; ，破口大骂之。看见这一场景，我默默地删掉了我在另一个地方写的 &lt;code&gt;new Thread(...)&lt;/code&gt; 当作无事发生（还好他没看见XD）。&lt;/p&gt;
&lt;p&gt;为了不再犯这种错误，我写下这篇文章来记录一下Java线程究竟该怎么使用（才不会被骂），也是开了一个新坑！&lt;/p&gt;</summary>
    
    
    
    <category term="技术小技巧" scheme="https://congregalis.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="Java" scheme="https://congregalis.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://congregalis.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java爬虫学习——从维基百科到多个数据源的爬取</title>
    <link href="https://congregalis.github.io/2021/04/28/Java%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BB%8EWikipedia%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%88%AC%E5%8F%96/"/>
    <id>https://congregalis.github.io/2021/04/28/Java%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E4%BB%8EWikipedia%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E7%88%AC%E5%8F%96/</id>
    <published>2021-04-28T08:56:18.000Z</published>
    <updated>2021-04-28T15:56:28.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本次学习的背景基于在实验室所做的工作，目的是构建一门课程信息。我负责的内容是根据给定的课程、课程的大纲等内容来爬取课程某个方面的具体内容。</p><p>万能的维基百科能查到所有东西，所以我以维基百科为基础先拿到某个课程下最基本的信息，然后再根据给定的课程与大纲去其他数据源上获取想要的内容，这就是本次学习的背景啦。</p><span id="more"></span><p>我强烈建议不管干什么，在编码前先要构建好清晰的思路，比如写个 Bullet List，画个流程图等，这样做事情事半功倍。那么我在这里也是以身作则一波，下面是我画的本次爬虫的流程图。<br><img src="/img/crawler4j/overall.jpg" alt="大致爬虫流程"></p><p>除此之外还需要考虑爬虫怎么写，由于项目时间紧，我就不重复造轮子了。浏览了一些开源框架后感觉 crawler4j 这个轻量级 Java 爬虫框架简单易用十分好上手。于是本次的开发就基于这个这个框架来进行。</p><h3 id="本次学习需要的东西"><a href="#本次学习需要的东西" class="headerlink" title="本次学习需要的东西"></a>本次学习需要的东西</h3><ul><li>maven</li><li>crawler4j (<a href="https://github.com/yasserg/crawler4j">仓库地址</a>)</li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>crawler4j这个爬虫框架主要基于三个类：Controller、Crawler、CrawlStat，简单介绍一下他们各自负责的事情：</p><ul><li>Controller：整个爬虫的控制器，设置一些参数如爬取深度、线程数量等来控制整个爬取过程。</li><li>Crawler：具体的爬虫线程，在里面真正执行爬取并分析爬到的数据。</li><li>CrawlStat：从爬虫线程中收集信息，如在某个页面爬取得的总文本字数、该页面下还有几个可以跳转的链接等。</li></ul><p>基本的爬虫实现在<a href="https://github.com/yasserg/crawler4j">crawler4j仓库</a>里已经说的很简洁明了了，如最最基础的爬取、爬取的一些参数设置、多爬虫爬取等，我这里就不再赘述。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>首先来看 Controller 类，其实这个 Controller 类并不是必要的，你也可以写在你需要启动爬虫的地方，主要是设置好 Config ，创建工厂启动就完事了。<br>这里还包含我自身项目的一些逻辑，比如课程、主题、分面等等，你可以不用在意，大致看一下如何实现就行了。</p><p><code>startBasicCrawler()</code> 方法是根据一个<strong>维基百科url</strong>爬取页面信息，比较简单，因为是单页面爬取一个爬虫线程就够用了。<br><code>startCrawlerForAssembleOnly()</code> 方法根据主题与分面名的拼接（你可以将主题理解成维基百科页面的大标题，分面理解成其下的一系列子标题）去 <strong>bing</strong> 上搜索，然后根据<strong>搜索页面</strong>来爬取，这里我使用了<strong>多爬虫任务</strong>，具体可以参照crawler4j仓库上的<a href="https://github.com/yasserg/crawler4j/tree/master/crawler4j-examples/crawler4j-examples-base/src/test/java/edu/uci/ics/crawler4j/examples/multiple">例子</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicCrawlerController</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger =<br>            LoggerFactory.getLogger(BasicCrawlerController.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据给定url爬取维基百科页面（这个url是在我的数据库中之前已经得到过的，你可以根据自身的逻辑来得到这个url）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startBasicCrawler</span><span class="hljs-params">(String url, <span class="hljs-keyword">boolean</span> isChinese, Long domainId, Long topicId)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CrawlConfig config = <span class="hljs-keyword">new</span> CrawlConfig();<br><br>        config.setCrawlStorageFolder(<span class="hljs-string">&quot;tmp/crawler4j/&quot;</span>);<br>        config.setPolitenessDelay(<span class="hljs-number">1000</span>);<br>        config.setMaxDepthOfCrawling(<span class="hljs-number">0</span>);<br>        config.setMaxPagesToFetch(<span class="hljs-number">1000</span>);<br>        config.setIncludeBinaryContentInCrawling(<span class="hljs-keyword">true</span>);<br>        config.setResumableCrawling(<span class="hljs-keyword">false</span>);<br><br>        PageFetcher pageFetcher = <span class="hljs-keyword">new</span> PageFetcher(config);<br>        RobotstxtConfig robotstxtConfig = <span class="hljs-keyword">new</span> RobotstxtConfig();<br>        RobotstxtServer robotstxtServer = <span class="hljs-keyword">new</span> RobotstxtServer(robotstxtConfig, pageFetcher);<br>        CrawlController controller = <span class="hljs-keyword">new</span> CrawlController(config, pageFetcher, robotstxtServer);<br><br>        controller.addSeed(url);<br><br>        <span class="hljs-keyword">int</span> numberOfCrawlers = <span class="hljs-number">2</span>;<br><br>        CrawlController.WebCrawlerFactory&lt;BasicCrawler&gt; factory =<br>                () -&gt; <span class="hljs-keyword">new</span> BasicCrawler(<span class="hljs-string">&quot;https://zh.wikipedia.org/wiki/&quot;</span>, isChinese, domainId, topicId);<br><br>        controller.start(factory, numberOfCrawlers);<br>        logger.info(<span class="hljs-string">&quot;Crawler is finished&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据给定课程、主题、分面列表，爬取分面列表下每个分面的碎片</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startCrawlerForAssembleOnly</span><span class="hljs-params">(Long domainId, Long topicId, List&lt;Facet&gt; facets)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> numberOfCrawlers = <span class="hljs-number">2</span>;<br>        String crawlStorageFolder = <span class="hljs-string">&quot;/tmp/crawler4j/&quot;</span>;<br>        List&lt;CrawlController&gt; crawlControllers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;CrawlController.WebCrawlerFactory&lt;CSDNCrawler&gt;&gt; crawlerFactories = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; facets.size(); i++) &#123;<br>            CrawlConfig config = <span class="hljs-keyword">new</span> CrawlConfig();<br><br>            config.setCrawlStorageFolder(crawlStorageFolder + <span class="hljs-string">&quot;/facet&quot;</span> + facets.get(i).getFacetName());<br>            config.setPolitenessDelay(<span class="hljs-number">1000</span>);<br>            config.setMaxDepthOfCrawling(<span class="hljs-number">0</span>);<br>            config.setMaxPagesToFetch(<span class="hljs-number">50</span>);<br>            config.setIncludeBinaryContentInCrawling(<span class="hljs-keyword">false</span>);<br>            config.setResumableCrawling(<span class="hljs-keyword">false</span>);<br><br>            <span class="hljs-comment">// Instantiate the controller for this crawl.</span><br>            PageFetcher pageFetcher = <span class="hljs-keyword">new</span> PageFetcher(config);<br>            RobotstxtConfig robotstxtConfig = <span class="hljs-keyword">new</span> RobotstxtConfig();<br>            robotstxtConfig.setEnabled(<span class="hljs-keyword">false</span>);<br>            RobotstxtServer robotstxtServer = <span class="hljs-keyword">new</span> RobotstxtServer(robotstxtConfig, pageFetcher);<br>            CrawlController controller = <span class="hljs-keyword">new</span> CrawlController(config, pageFetcher, robotstxtServer);<br><br>            String topicName = MysqlReadWriteDAO.findTopicNameByTopicId(topicId);<br>            config.setMaxDepthOfCrawling(<span class="hljs-number">1</span>);<br>            config.setMaxPagesToFetch(<span class="hljs-number">50</span>);<br><br>            String facetName = facets.get(i).getFacetName();<br><br>            <span class="hljs-comment">// 根据维基百科上爬取到的标题、副标题等去bing上搜索</span><br>            String targetURL = <span class="hljs-string">&quot;https://cn.bing.com/search?q=&quot;</span> + topicName + facetName;<br>            controller.addSeed(targetURL);<br>            CrawlController.WebCrawlerFactory&lt;CSDNCrawler&gt; csdnFactory =<br>                    () -&gt; <span class="hljs-keyword">new</span> CSDNCrawler(<span class="hljs-string">&quot;https://cn.bing.com/search?q=&quot;</span>, <span class="hljs-keyword">true</span>, domainId, topicId, facetName);<br><br>            crawlControllers.add(controller);<br>            crawlerFactories.add(csdnFactory);<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; facets.size(); i++) &#123;<br>            crawlControllers.get(i).startNonBlocking(crawlerFactories.get(i), numberOfCrawlers);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; facets.size(); i++) &#123;<br>            crawlControllers.get(i).waitUntilFinish();<br>            logger.info(<span class="hljs-string">&quot;Crawler for &quot;</span> + facets.get(i).getFacetName() +  <span class="hljs-string">&quot; is finished.&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Crawler"><a href="#Crawler" class="headerlink" title="Crawler"></a>Crawler</h3><p>然后来说一下核心类，也就是 Crawler。因为维基百科页面和下一步爬搜索页面的逻辑不太一样，所以我写了两个Crawler类。代码可能比较长，不过核心内容都在 <code>run()</code> 方法中，也就是对爬取到的页面进行解析，这也是比较核心的部分。<br>建议主要看我写的第二个Crawler，也是爬取搜索页面的爬虫线程，那个写的逻辑比较清晰。</p><p>爬取维基百科页面的 <strong>Crawler</strong> (写的可能比较乱，所以我把他折叠一下)：</p><details>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicCrawler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebCrawler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Pattern FILTERS = Pattern.compile(<br>            <span class="hljs-string">&quot;.*(\\.(css|js|bmp|gif|jpe?g|png|tiff?|mid|mp2|mp3|mp4|wav|avi|mov|mpeg|ram|m4v|pdf&quot;</span> +<br>                    <span class="hljs-string">&quot;|rm|smil|wmv|swf|wma|zip|rar|gz))$&quot;</span>);<br>    <span class="hljs-keyword">private</span> String DOMAIN;<br>    <span class="hljs-keyword">private</span> CrawlerStat myCrawlerStat;<br>    <span class="hljs-keyword">private</span> Document document;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isChinese;<br>    <span class="hljs-keyword">private</span> Long domainId;<br>    <span class="hljs-keyword">private</span> Long topicId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Creates a new crawler instance.</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BasicCrawler</span><span class="hljs-params">(String DOMAIN, <span class="hljs-keyword">boolean</span> isChinese, Long domainId, Long topicId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.DOMAIN = DOMAIN;<br>        <span class="hljs-keyword">this</span>.isChinese = isChinese;<br>        <span class="hljs-keyword">this</span>.domainId = domainId;<br>        <span class="hljs-keyword">this</span>.topicId = topicId;<br>        myCrawlerStat = <span class="hljs-keyword">new</span> CrawlerStat();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldVisit</span><span class="hljs-params">(Page referringPage, WebURL url)</span> </span>&#123;<br>        String href = url.getURL().toLowerCase();<br><br>        <span class="hljs-keyword">return</span> !FILTERS.matcher(href).matches() &amp;&amp; href.startsWith(DOMAIN);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;===================================================================================&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;Visited: &#123;&#125;&quot;</span>, page.getWebURL().getURL());<br>        myCrawlerStat.incProcessedPages();<br><br>        List&lt;String&gt; facetNameList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">if</span> (page.getParseData() <span class="hljs-keyword">instanceof</span> HtmlParseData) &#123;<br>            HtmlParseData htmlParseData = (HtmlParseData) page.getParseData();<br>            String text = htmlParseData.getText();<br>            String html = htmlParseData.getHtml();<br>            Set&lt;WebURL&gt; links = htmlParseData.getOutgoingUrls();<br><br>            document = Jsoup.parse(html);<br>            Elements contents = document.select(<span class="hljs-string">&quot;div[class=mw-parser-output]&quot;</span>);<br>            Element content = contents.get(<span class="hljs-number">0</span>);<br><br>            String facetName = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (Object child : content.childNodes()) &#123;<br>                <span class="hljs-keyword">if</span> (child <span class="hljs-keyword">instanceof</span> Element) &#123;<br><br>                    Long facetLevel1; <span class="hljs-comment">// 一级分面id</span><br>                    Long facetLevel2; <span class="hljs-comment">// 二级分面id</span><br><br>                    <span class="hljs-comment">// 获取一级分面名 （即h2标题）</span><br>                    <span class="hljs-keyword">if</span> (((Element) child).tag().getName().equals(<span class="hljs-string">&quot;h2&quot;</span>)) &#123;<br>                        <span class="hljs-comment">// 这里由于中英文页面样式不同，需要分开处理</span><br>                        facetName = isChinese ? ((Element) child).child(<span class="hljs-number">1</span>).text() : ((Element) child).child(<span class="hljs-number">0</span>).text();<br>                    &#125;<br><br>                    <span class="hljs-comment">// 获取二级分面名 （即h3标题）</span><br>                    <span class="hljs-keyword">if</span> (((Element) child).tag().getName().equals(<span class="hljs-string">&quot;h3&quot;</span>)) &#123;<br>                        <span class="hljs-comment">// 可以再根据二级子标题进行一些其他处理...</span><br>                    &#125;<br><br>                    <span class="hljs-comment">// 获取碎片 （即h2标题下的文本）</span><br>                    <span class="hljs-keyword">if</span> (((Element) child).tag().getName().equals(<span class="hljs-string">&quot;p&quot;</span>)) &#123;<br>                        String assembleHtml = ((Element) child).html();<br>                        String assemble = ((Element) child).text();<br><br>                        <span class="hljs-keyword">if</span> (facetName == <span class="hljs-keyword">null</span>) &#123;<br>                            <span class="hljs-comment">// 为每个主题加上一个定义</span><br>                            <span class="hljs-keyword">if</span> ((!isChinese &amp;&amp; assemble.split(<span class="hljs-string">&quot; &quot;</span>).length &gt; <span class="hljs-number">2</span> || isChinese &amp;&amp; assemble.length() &gt; <span class="hljs-number">2</span>) &amp;&amp; !assembleHtml.equals(<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>)) &#123;<br>                                String definition = isChinese ? <span class="hljs-string">&quot;定义&quot;</span> : <span class="hljs-string">&quot;Definition&quot;</span>;<br><br>                                System.out.println(<span class="hljs-string">&quot;获取到分面：&quot;</span> + definition);<br>                                System.out.println(<span class="hljs-string">&quot;获取到碎片：&quot;</span> + assemble);<br>                                System.out.println(<span class="hljs-string">&quot;碎片html格式：&quot;</span> + assembleHtml);<br>                                System.out.println(<span class="hljs-string">&quot;课程ID：&quot;</span> + domainId + <span class="hljs-string">&quot; 主题ID：&quot;</span> + topicId);<br><br>                                <span class="hljs-comment">// 在数据库中存储相应分面及碎片</span><br>                                Long facetId = MysqlReadWriteDAO.findByTopicIdAndFacetName(topicId, definition);<br>                                <span class="hljs-keyword">if</span> (facetId == -<span class="hljs-number">1L</span>) &#123;<br>                                    List&lt;FacetSimple&gt; facetList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                                    facetList.add(<span class="hljs-keyword">new</span> FacetSimple(definition, <span class="hljs-number">1</span>));<br>                                    <span class="hljs-keyword">try</span> &#123;<br>                                        MysqlReadWriteDAO.storeFacet(topicId, facetList); <span class="hljs-comment">// 存分面</span><br>                                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                        e.printStackTrace();<br>                                    &#125;<br>                                    facetId = MysqlReadWriteDAO.findByTopicIdAndFacetName(topicId, definition);<br>                                &#125;<br><br>                                MysqlReadWriteDAO.storeAssemble(assembleHtml, assemble, domainId, facetId, <span class="hljs-number">1L</span>); <span class="hljs-comment">// 存碎片</span><br>                                facetNameList.add(definition);<br>                            &#125;<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!facetName.equals(<span class="hljs-string">&quot;&quot;</span>) &amp;&amp; !assemble.equals(<span class="hljs-string">&quot;&quot;</span>) &amp;&amp;<br>                                (!isChinese &amp;&amp; assemble.split(<span class="hljs-string">&quot; &quot;</span>).length &gt; <span class="hljs-number">2</span> || isChinese &amp;&amp; assemble.length() &gt; <span class="hljs-number">2</span>) &amp;&amp;<br>                                !assembleHtml.equals(<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>)) &#123;<br>                            System.out.println(<span class="hljs-string">&quot;获取到分面：&quot;</span> + facetName);<br>                            System.out.println(<span class="hljs-string">&quot;获取到碎片：&quot;</span> + assemble);<br>                            System.out.println(<span class="hljs-string">&quot;碎片html格式：&quot;</span> + assembleHtml);<br>                            System.out.println(<span class="hljs-string">&quot;课程ID：&quot;</span> + domainId + <span class="hljs-string">&quot; 主题ID：&quot;</span> + topicId);<br><br>                            <span class="hljs-comment">// 在数据库中存储相应分面及碎片</span><br>                            Long facetId = MysqlReadWriteDAO.findByTopicIdAndFacetName(topicId, facetName);<br>                            <span class="hljs-keyword">if</span> (facetId == -<span class="hljs-number">1L</span>) &#123;<br>                                List&lt;FacetSimple&gt; facetList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                                facetList.add(<span class="hljs-keyword">new</span> FacetSimple(facetName, <span class="hljs-number">1</span>));<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    MysqlReadWriteDAO.storeFacet(topicId, facetList); <span class="hljs-comment">// 存分面</span><br>                                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                    e.printStackTrace();<br>                                &#125;<br>                                facetId = MysqlReadWriteDAO.findByTopicIdAndFacetName(topicId, facetName);<br>                            &#125;<br><br>                            MysqlReadWriteDAO.storeAssemble(assembleHtml, assemble, domainId, facetId, <span class="hljs-number">1L</span>); <span class="hljs-comment">// 存碎片</span><br>                            facetNameList.add(facetName);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            myCrawlerStat.setFacetNameList(facetNameList);<br>            logger.debug(<span class="hljs-string">&quot;Text length: &#123;&#125;&quot;</span>, text.length());<br>            logger.debug(<span class="hljs-string">&quot;Html length: &#123;&#125;&quot;</span>, html.length());<br>            logger.debug(<span class="hljs-string">&quot;Number of outgoing links: &#123;&#125;&quot;</span>, links.size());<br><br>            myCrawlerStat.incTotalLinks(links.size());<br>            <span class="hljs-keyword">try</span> &#123;<br>                myCrawlerStat.incTotalTextSize(text.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>).length);<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;不支持的编码类型&quot;</span>);<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 每处理一个page转储一下数据</span><br>        <span class="hljs-keyword">if</span> (myCrawlerStat.getTotalProcessedPages() &gt; <span class="hljs-number">0</span>) &#123;<br>            dumpMyData();<br>        &#125;<br><br>        logger.info(<span class="hljs-string">&quot;===================================================================================&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBeforeExit</span><span class="hljs-params">()</span> </span>&#123;<br>        dumpMyData();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getMyLocalData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myCrawlerStat;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dumpMyData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> id = getMyId();<br>        <span class="hljs-comment">// You can configure the log to output to file</span><br>        logger.info(<span class="hljs-string">&quot;Crawler &#123;&#125; &gt; Processed Pages: &#123;&#125;&quot;</span>, id, myCrawlerStat.getTotalProcessedPages());<br>        logger.info(<span class="hljs-string">&quot;Crawler &#123;&#125; &gt; Total Links Found: &#123;&#125;&quot;</span>, id, myCrawlerStat.getTotalLinks());<br>        logger.info(<span class="hljs-string">&quot;Crawler &#123;&#125; &gt; Total Text Size: &#123;&#125;&quot;</span>, id, myCrawlerStat.getTotalTextSize());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></details><p>爬取搜索页面的 <strong>Crawler</strong>：<br>这里我的逻辑是</p><ol><li>以搜索页面为seed，拿到一系列搜索结果页面；</li><li>根据不同的源（这里可以自己添加想要的数据源，如简书、CSDN等）过滤出想要爬取的页面；</li><li>针对每个源做不同的HTML解析。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.xjtu.spider_new.spiders.csdn;<br><br><span class="hljs-keyword">import</span> com.xjtu.facet.domain.FacetSimple;<br><span class="hljs-keyword">import</span> com.xjtu.spider_new.spiders.CrawlerStat;<br><span class="hljs-keyword">import</span> com.xjtu.spider_new.spiders.wikicn.MysqlReadWriteDAO;<br><span class="hljs-keyword">import</span> edu.uci.ics.crawler4j.crawler.Page;<br><span class="hljs-keyword">import</span> edu.uci.ics.crawler4j.crawler.WebCrawler;<br><span class="hljs-keyword">import</span> edu.uci.ics.crawler4j.parser.HtmlParseData;<br><span class="hljs-keyword">import</span> edu.uci.ics.crawler4j.url.WebURL;<br><span class="hljs-keyword">import</span> org.jsoup.Jsoup;<br><span class="hljs-keyword">import</span> org.jsoup.nodes.Document;<br><span class="hljs-keyword">import</span> org.jsoup.nodes.Element;<br><span class="hljs-keyword">import</span> org.jsoup.select.Elements;<br><br><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchCrawler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebCrawler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Pattern FILTERS = Pattern.compile(<br>            <span class="hljs-string">&quot;.*(\\.(css|js|bmp|gif|jpe?g|png|tiff?|mid|mp2|mp3|mp4|wav|avi|mov|mpeg|ram|m4v|pdf&quot;</span> +<br>                    <span class="hljs-string">&quot;|rm|smil|wmv|swf|wma|zip|rar|gz))$&quot;</span>);<br>    <span class="hljs-keyword">private</span> String DOMAIN;<br>    <span class="hljs-keyword">private</span> CrawlerStat myCrawlerStat;<br>    <span class="hljs-keyword">private</span> Document document;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isChinese;<br>    <span class="hljs-keyword">private</span> Long domainId;<br>    <span class="hljs-keyword">private</span> Long topicId;<br>    <span class="hljs-keyword">private</span> String facetName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SearchCrawler</span><span class="hljs-params">(String DOMAIN, <span class="hljs-keyword">boolean</span> isChinese, Long domainId, Long topicId, String facetName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.DOMAIN = DOMAIN;<br>        <span class="hljs-keyword">this</span>.isChinese = isChinese;<br>        <span class="hljs-keyword">this</span>.domainId = domainId;<br>        <span class="hljs-keyword">this</span>.topicId = topicId;<br>        <span class="hljs-keyword">this</span>.facetName = facetName;<br>        myCrawlerStat = <span class="hljs-keyword">new</span> CrawlerStat();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldVisit</span><span class="hljs-params">(Page referringPage, WebURL url)</span> </span>&#123;<br>        String href = url.getURL().toLowerCase();<br><br>        <span class="hljs-comment">// 过滤出自己想要爬取的域</span><br>        <span class="hljs-keyword">return</span> !FILTERS.matcher(href).matches() &amp;&amp;<br>                (href.startsWith(<span class="hljs-string">&quot;https://blog.csdn.net/&quot;</span>) || href.startsWith(<span class="hljs-string">&quot;https://www.cnblogs.com/&quot;</span>) ||<br>                    href.startsWith(<span class="hljs-string">&quot;https://www.jianshu.com/&quot;</span>) || href.startsWith(<span class="hljs-string">&quot;https://baike.baidu.com/&quot;</span>) ||<br>                        href.equals(DOMAIN.toLowerCase()));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;===================================================================================&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;Visited: &#123;&#125;&quot;</span>, page.getWebURL().getURL());<br>        myCrawlerStat.incProcessedPages();<br><br><br>        <span class="hljs-keyword">if</span> (page.getParseData() <span class="hljs-keyword">instanceof</span> HtmlParseData) &#123;<br>            HtmlParseData htmlParseData = (HtmlParseData) page.getParseData();<br>            String text = htmlParseData.getText();<br>            String html = htmlParseData.getHtml();<br>            Set&lt;WebURL&gt; links = htmlParseData.getOutgoingUrls();<br><br>            String domain = page.getWebURL().getDomain(); <span class="hljs-comment">// 查看当前爬的是哪个域</span><br><br>            <span class="hljs-keyword">switch</span> (domain) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bing.com&quot;</span>:<br>                    logger.info(<span class="hljs-string">&quot;当前域为搜索页面，不进行处理&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jianshu.com&quot;</span>:<br>                    <span class="hljs-comment">// 解析简书页面</span><br>                    parseJianshu(html);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;csdn.net&quot;</span>:<br>                    <span class="hljs-comment">// 解析CSDN页面</span><br>                    parseCSDN(html);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;cnblogs.com&quot;</span>:<br>                    <span class="hljs-comment">// 解析博客园页面</span><br>                    parseCNBlog(html);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    logger.error(<span class="hljs-string">&quot;未知源&quot;</span>);<br>            &#125;<br><br>            logger.debug(<span class="hljs-string">&quot;Text length: &#123;&#125;&quot;</span>, text.length());<br>            logger.debug(<span class="hljs-string">&quot;Html length: &#123;&#125;&quot;</span>, html.length());<br>            logger.debug(<span class="hljs-string">&quot;Number of outgoing links: &#123;&#125;&quot;</span>, links.size());<br><br>            myCrawlerStat.incTotalLinks(links.size());<br>            <span class="hljs-keyword">try</span> &#123;<br>                myCrawlerStat.incTotalTextSize(text.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>).length);<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;不支持的编码类型&quot;</span>);<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 每处理一个page转储一下数据</span><br>        <span class="hljs-keyword">if</span> (myCrawlerStat.getTotalProcessedPages() &gt; <span class="hljs-number">0</span>) &#123;<br>            dumpMyData();<br>        &#125;<br><br>        logger.info(<span class="hljs-string">&quot;===================================================================================&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析简书html</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> html 源数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseJianshu</span><span class="hljs-params">(String html)</span> </span>&#123;<br>        Document document = Jsoup.parse(html);<br>        Elements article = document.select(<span class="hljs-string">&quot;div[class=show-content-free]&quot;</span>);<br>        String articleHTML = article.html();<br>        String articleContent = article.text();<br>        System.out.println(articleContent);<br>        storeAssemble(articleHTML, articleContent, <span class="hljs-number">17L</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseCSDN</span><span class="hljs-params">(String html)</span> </span>&#123;<br>        Document document = Jsoup.parse(html);<br>        Elements article = document.select(<span class="hljs-string">&quot;div[id=content_views]&quot;</span>);<br>        String articleHTML = article.html();<br>        String articleContent = article.text();<br>        System.out.println(articleContent);<br>        storeAssemble(articleHTML, articleContent, <span class="hljs-number">4L</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseCNBlog</span><span class="hljs-params">(String html)</span> </span>&#123;<br>        Document document = Jsoup.parse(html);<br>        Elements article = document.select(<span class="hljs-string">&quot;div[id=cnblogs_post_body]&quot;</span>);<br>        String articleHTML = article.html();<br>        String articleContent = article.text();<br>        System.out.println(articleContent);<br>        storeAssemble(articleHTML, articleContent, <span class="hljs-number">13L</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 存储爬到的碎片</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> articleHTML 碎片 html</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> articleContent 碎片 text</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storeAssemble</span><span class="hljs-params">(String articleHTML, String articleContent, Long sourceId)</span> </span>&#123;<br>        <span class="hljs-comment">// 在数据库中存储相应分面及碎片</span><br>        Long facetId = MysqlReadWriteDAO.findByTopicIdAndFacetName(topicId, facetName);<br>        <span class="hljs-keyword">if</span> (facetId == -<span class="hljs-number">1L</span>) &#123;<br>            List&lt;FacetSimple&gt; facetList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            facetList.add(<span class="hljs-keyword">new</span> FacetSimple(facetName, <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">try</span> &#123;<br>                MysqlReadWriteDAO.storeFacet(topicId, facetList); <span class="hljs-comment">// 存分面</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            facetId = MysqlReadWriteDAO.findByTopicIdAndFacetName(topicId, facetName);<br>        &#125;<br><br>        MysqlReadWriteDAO.storeAssemble(articleHTML, articleContent, domainId, facetId, sourceId); <span class="hljs-comment">// 存碎片</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBeforeExit</span><span class="hljs-params">()</span> </span>&#123;<br>        dumpMyData();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getMyLocalData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> myCrawlerStat;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dumpMyData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> id = getMyId();<br>        <span class="hljs-comment">// You can configure the log to output to file</span><br>        logger.info(<span class="hljs-string">&quot;Crawler &#123;&#125; &gt; Processed Pages: &#123;&#125;&quot;</span>, id, myCrawlerStat.getTotalProcessedPages());<br>        logger.info(<span class="hljs-string">&quot;Crawler &#123;&#125; &gt; Total Links Found: &#123;&#125;&quot;</span>, id, myCrawlerStat.getTotalLinks());<br>        logger.info(<span class="hljs-string">&quot;Crawler &#123;&#125; &gt; Total Text Size: &#123;&#125;&quot;</span>, id, myCrawlerStat.getTotalTextSize());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="CrawlStat"><a href="#CrawlStat" class="headerlink" title="CrawlStat"></a>CrawlStat</h3><p>最后是 CrawlStat 类，这个类可以用来返回<strong>爬取过某个页面后得到的信息</strong>，我也只是在官方示例上加入了爬到的分面（即子标题名）列表信息，以供我链式的调用<strong>爬维基百科+搜索</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xjtu.spider_new.spiders;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CrawlerStat</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalProcessedPages;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> totalLinks;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> totalTextSize;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; facetNameList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTotalProcessedPages</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> totalProcessedPages;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalProcessedPages</span><span class="hljs-params">(<span class="hljs-keyword">int</span> totalProcessedPages)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.totalProcessedPages = totalProcessedPages;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incProcessedPages</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.totalProcessedPages++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotalLinks</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> totalLinks;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalLinks</span><span class="hljs-params">(<span class="hljs-keyword">long</span> totalLinks)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.totalLinks = totalLinks;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotalTextSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> totalTextSize;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotalTextSize</span><span class="hljs-params">(<span class="hljs-keyword">long</span> totalTextSize)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.totalTextSize = totalTextSize;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incTotalLinks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.totalLinks += count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incTotalTextSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.totalTextSize += count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getFacetNameList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> facetNameList;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFacetNameList</span><span class="hljs-params">(List&lt;String&gt; facetNameList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.facetNameList = facetNameList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于crawler4j这个框架来进行Java的爬虫开发还是比较简单的，框架内帮助我们做好了爬虫线程的分配、爬虫的一些设置如robotstxt设置、代理设置等等。在它之上进行开发其实要关注的核心只有2点：<strong>什么页面需要爬</strong>和<strong>页面解析</strong>。需要爬什么页面取决与你的目的，如果像我一开始用流程图规划好了相信并不难弄，而页面解析则需要你会一些前端知识，在需要爬取的页面上先人工去模拟需要些什么数据，然后用 <strong>F12</strong> 来进行定位，最后使用 <strong>Jsoup</strong> 进行解析。</p><p>除此之外crawler4j的源码还是很值得学习的，如果有时间，我会去研究研究并且写一些记录。</p><h2 id="TO-DO"><a href="#TO-DO" class="headerlink" title="TO-DO"></a>TO-DO</h2><p>目前其实还有很多不足的地方，如果有时间了我会一一改进并且把代码重构一下，然后抽离出原本的项目做成一个可以直接使用的东西。</p><ul><li><input disabled="" type="checkbox"> 增加更多的数据源</li><li><input disabled="" type="checkbox"> 实时返回爬取进度</li><li><input disabled="" type="checkbox"> 代码重构</li><li><input disabled="" type="checkbox"> 抽离代码</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;本次学习的背景基于在实验室所做的工作，目的是构建一门课程信息。我负责的内容是根据给定的课程、课程的大纲等内容来爬取课程某个方面的具体内容。&lt;/p&gt;
&lt;p&gt;万能的维基百科能查到所有东西，所以我以维基百科为基础先拿到某个课程下最基本的信息，然后再根据给定的课程与大纲去其他数据源上获取想要的内容，这就是本次学习的背景啦。&lt;/p&gt;</summary>
    
    
    
    <category term="小项目" scheme="https://congregalis.github.io/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="crawler4j" scheme="https://congregalis.github.io/tags/crawler4j/"/>
    
    <category term="爬虫" scheme="https://congregalis.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>简单题看中序遍历</title>
    <link href="https://congregalis.github.io/2021/04/25/%E7%AE%80%E5%8D%95%E9%A2%98%E7%9C%8B%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://congregalis.github.io/2021/04/25/%E7%AE%80%E5%8D%95%E9%A2%98%E7%9C%8B%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2021-04-25T06:34:09.000Z</published>
    <updated>2021-04-29T15:42:46.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>题目是今天的每日一题<a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">LC897</a><br><img src="/img/20210425inorder/problem.png"></p><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>我总是喜欢从最简单粗暴的方法开始，这个最后的结果看起来不就是个链表吗？那我们就直接把他当列表存储下来然后再一个一个按要求连上。</p><span id="more"></span><h3 id="递归-使用list存储"><a href="#递归-使用list存储" class="headerlink" title="递归 + 使用list存储"></a>递归 + 使用list存储</h3><p>递归的思路比较简单，中序遍历在递归函数中按左结点-本结点-右结点的顺序处理即可。<br>在最后连接的时候我这里写的比较复杂，这是因为在处理列表第一个结点和其余结点的时候情况不同需要分开。针对这个问题可以添加一个哨兵在头部，就可以巧妙处理啦，具体代码可以看我的下一个解法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        inorder(root); <span class="hljs-comment">// 按中序遍历顺序添加到列表里</span><br><br>        <span class="hljs-comment">// 按列表顺序一个个连接上</span><br>        root = list.get(<span class="hljs-number">0</span>);<br>        TreeNode curr = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; list.size(); i++) &#123;<br>            curr.left = <span class="hljs-keyword">null</span>;<br>            curr.right = list.get(i);<br>            curr = curr.right;<br>        &#125;<br>        curr.left = <span class="hljs-keyword">null</span>;<br>        curr.right = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <br><br>        inorder(root.left);<br>        list.add(root);<br>        inorder(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代-使用list存储"><a href="#迭代-使用list存储" class="headerlink" title="迭代 + 使用list存储"></a>迭代 + 使用list存储</h3><p>谈到中序遍历往往都会谈到有<strong>递归</strong>与<strong>迭代</strong>两种方式，迭代的方式比较复杂，但也很重要必须要掌握。</p><p>迭代需要一个<strong>栈</strong>来实现，具体思路：</p><ol><li>每到一个结点 node ，将其入栈。（因为中序里先遍历的结点是左结点，所以当前结点不着急访问）</li><li>遍历它的左子树，将该结点变成当前节点，一直直到当前结点为空。</li><li>由于当前结点为空，说明上一个结点没有左子树了，于是拿出栈顶元素进行访问。</li><li>访问完后遍历右子树，遍历步骤同上。</li><li>重复以上步骤直到栈为空（没有上一级结点访问了）</li></ol><p>我这里讲的比较详细，可能看起来比较吃力，具体细节可以看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// 迭代做法</span><br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !deque.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                deque.addLast(root);<br>                root = root.left;<br>            &#125;<br>            root = deque.pollLast();<br>            list.add(root);<br>            root = root.right;<br>        &#125;<br><br>        TreeNode dummy = <span class="hljs-keyword">new</span> TreeNode(-<span class="hljs-number">1</span>);<br>        TreeNode curr = dummy;<br>        <span class="hljs-keyword">for</span> (TreeNode node : list) &#123;<br>            curr.right = node;<br>            node.left = <span class="hljs-keyword">null</span>;<br>            curr = curr.right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代-只记录上一个结点"><a href="#迭代-只记录上一个结点" class="headerlink" title="迭代 + 只记录上一个结点"></a>迭代 + 只记录上一个结点</h3><p>使用list来记录中序遍历的顺序是一个简单且不容易出错的一个方法。<br>但是这样有违我们简洁优雅的原则，其实没有必要去申请这么大的一个空间，用一个遍历来记录中序遍历过程中的上一个结点，并且在中序遍历的过程中直接就可以把结果弄好。具体参考下面代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// 迭代 + 记录上一个结点</span><br>        TreeNode dummy = <span class="hljs-keyword">new</span> TreeNode(-<span class="hljs-number">1</span>);<br>        TreeNode pre = dummy;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span> || !deque.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                deque.addLast(root);<br>                root = root.left;<br>            &#125;<br>            root = deque.pollLast();<br>            pre.right = root;<br>            root.left = <span class="hljs-keyword">null</span>;<br>            pre = pre.right;<br>            root = root.right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.right;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="递归-只记录上一个结点"><a href="#递归-只记录上一个结点" class="headerlink" title="递归 + 只记录上一个结点"></a>递归 + 只记录上一个结点</h3><p>留给你们去思考，看懂了上面三个方法相信做出这个解并不困难。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>中序遍历在树的遍历中是一个很常见且很重要的形式。基本上掌握这里的递归+迭代方法就差不多啦，这里把list替换为只记录前一个结点的技巧其实也是很常用的。值得一提的是，在二叉搜索树中中序遍历序列其实就是一个有序数组噢。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>有什么相关题目值得一做的我会补充在这里。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;题目是今天的每日一题&lt;a href=&quot;https://leetcode-cn.com/problems/increasing-order-search-tree/&quot;&gt;LC897&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/img/20210425inorder/problem.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;解&quot;&gt;&lt;a href=&quot;#解&quot; class=&quot;headerlink&quot; title=&quot;解&quot;&gt;&lt;/a&gt;解&lt;/h2&gt;&lt;p&gt;我总是喜欢从最简单粗暴的方法开始，这个最后的结果看起来不就是个链表吗？那我们就直接把他当列表存储下来然后再一个一个按要求连上。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://congregalis.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树" scheme="https://congregalis.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Flutter初识——创建第一个跨平台APP</title>
    <link href="https://congregalis.github.io/2021/04/24/Flutter%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%B7%A8%E5%B9%B3%E5%8F%B0APP/"/>
    <id>https://congregalis.github.io/2021/04/24/Flutter%E5%88%9D%E8%AF%86%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%B7%A8%E5%B9%B3%E5%8F%B0APP/</id>
    <published>2021-04-24T11:12:05.000Z</published>
    <updated>2021-05-12T12:23:19.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近声网办了一个编程挑战赛，用他们的 SDK 来开发应用。我也是对此比较感兴趣就想了解了解，同时做个作品。但是我对于前端的东西 js 一类的比较反感哈哈，不太想去学，于是就看看移动端上有没有什么易于开发的东西。之前也是读过《第一行代码》，学过安卓，但是安卓的更新迭代太快了，以前的安卓项目现在都没法运行起来了，故也不太想捣鼓安卓。</p><span id="more"></span><p>这个时候我看到了 Flutter ，对此颇感兴趣，浏览了一下官方文档以及一些 flutter 的社区，感觉生态环境都还不错，所以准备入坑！那么在这里也是记录一下我的一个入坑过程。</p><p>简单介绍一下，Flutter 就是一个<strong>跨平台开发</strong>的框架，可以帮助我们通过一套代码库高效地构建多平台精美应用，包括 Android、IOS、Web、桌面应用等。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>如果要跨平台开发，那么Mac肯定是首选工具，否则你就只能开发安卓应用了。</p><p>如果你要开发安卓应用，那么你需要</p><ul><li>Flutter SDK</li><li>Android SDK</li><li>Android Studio 或者 VSCode</li></ul><p>如果你要开发IOS应用，那么你需要</p><ul><li>Flutter SDK</li><li>Xcode</li></ul><p>这里我的 Flutter SDK 用的是<strong>1.22.6</strong>，因为声网官网上说了目前还不支持 Flutter 2.x。获取特定的SDK版本下载可以看<a href="https://flutter.cn/docs/development/tools/sdk/releases">这里</a></p><p>为了获得比较轻量级的编辑体验，我使用的是 VSCode，安装了<strong>Flutter</strong>和<strong>Dart</strong>两个插件</p><p>将以上环境都安装配置好之后（记得配置环境变量），就可以愉快的开始开发了。</p><blockquote><p>Hint: 测试可以在虚拟机或者自己的手机上进行，有什么问题运行 <code>flutter doctor</code> 都可以找到问题并解决</p></blockquote><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>开发第一个程序，“Hello World”那是必不可少的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br>  runApp(<br>    Center(<br>      child: Text(<br>        <span class="hljs-string">&#x27;Hello World&#x27;</span>,<br>        textDirection: TextDirection.ltr,<br>      ),<br>    ),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>非常的简单，主屏幕上就会展示“Hello World”了。</p><p>Flutter 使用的语言是 Dart ，如果你像我一样比较熟悉面向对象语言，那么相信你很容易就能上手。</p><h2 id="第一个App"><a href="#第一个App" class="headerlink" title="第一个App"></a>第一个App</h2><p>这里我用的是官方文档上“编写第一个Flutter应用”的例子，在那里它说的十分清楚，留一个<a href="https://flutter.cn/docs/get-started/codelab">传送门</a>。</p><p>跟着它的教程可以很容易的构建出第一个应用并且熟悉基础的 flutter app 编写，比如如何绘制UI，如何响应按钮按下的动作等等。</p><p><img src="/img/flutter1/firstappv1.png" alt="图来自flutter官方文档"></p><h2 id="加入白天-黑夜模式切换"><a href="#加入白天-黑夜模式切换" class="headerlink" title="加入白天/黑夜模式切换"></a>加入白天/黑夜模式切换</h2><p>为了更好的体验 flutter，在它的例子基础上我加入了切换白天/黑夜浏览模式这个功能。通过右上角的<strong>小灯泡</strong>可以实现模式的切换，并且在进入收藏列表后白天/黑夜主题也会保持一致。</p><center class="half">    <img src = "/img/flutter1/android-day.png" width = "400"/>    <img src = "/img/flutter1/android-night.png" width = "400"/></center><br><p>那么接下来就来看看这是怎么实现的</p><h3 id="加入小灯泡"><a href="#加入小灯泡" class="headerlink" title="加入小灯泡"></a>加入小灯泡</h3><p>这一步非常好做，在官方介绍的教程里也说了如何在 AppBar 上加入一个带图标的按钮，在此基础上再加一个就行啦。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">Scaffold</span>(<br>        <span class="hljs-attribute">appBar</span>: AppBar(<br>          <span class="hljs-attribute">title</span>: Text(<span class="hljs-string">&#x27;名字生成器&#x27;</span>),<br>          <span class="hljs-comment">// backgroundColor: barColor,</span><br>          <span class="hljs-attribute">actions</span>: &lt;Widget&gt;[<br>            new IconButton(<br>                <span class="hljs-attribute">icon</span>: const Icon(Icons.lightbulb_outlined),<br>                <span class="hljs-attribute">onPressed</span>: _switchDarkMode),<br>            new IconButton(<span class="hljs-attribute">icon</span>: const Icon(Icons.list), <span class="hljs-attribute">onPressed</span>: _pushSaved),<br>          ],<br>        ),<br>        <span class="hljs-attribute">body</span>: _buildSuggestions(),<br>      );<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>加这个功能的想法其实就是从官方教程上说到主题那里来的。我在反复的测试都有些什么主题的时候发现了有<code>ThemeData.dark()</code>和<code>ThemeData.light()</code>两个有意思的东西，我就在想何不做一个主题切换呢？但是在真正做的时候其实还是困扰了我很久的，毕竟我比较菜。</p><p>于是我就上网查了一下，发现通过调用<strong>setState</strong>并重写里面的方法可以做到改变界面的一些状态。但是你会发现，<strong>theme</strong>是在<strong>MaterialApp</strong>下的，而如果你是按官方教程做的，它在重写 build 方法时只构建了 Scaffold ，而把 MaterialApp 的构建写在了 Myapp 里。这就导致如果你想通过 Scaffold 里的按钮改变主题，那必须得修改上层 MaterialApp 的 theme ，而他们又不在一个类中，不属于一个 Widget，<strong>这个时候调用 setState 无法改变到 theme</strong>。</p><p>我也是上网查到有很多种方案，但大都比较复杂，有的甚至需要导入一些外部包。本着简洁高效的我当然不接受这样做了，于是我想出了另一个方案，不知道适不适合，在这里供大家一看。</p><p>首先，既然 theme 只能在 MaterialApp 里指定，那我就在重写 build 方法的时候在外面再套一层 MaterialApp 不就可以了嘛。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 在类里定义好themeData与当前模式两个变量</span><br>ThemeData themeData = <span class="hljs-keyword">new</span> ThemeData.dark();<br><span class="hljs-built_in">bool</span> isDark = <span class="hljs-keyword">true</span>;<br><br><span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp( <span class="hljs-comment">// 再加一层MaterialApp，在里面指定theme</span><br>      title: <span class="hljs-string">&#x27;名字生成器&#x27;</span>,<br>      theme: themeData,<br>      home: Scaffold(<br>        appBar: AppBar(<br>          title: Text(<span class="hljs-string">&#x27;名字生成器&#x27;</span>),<br>          <span class="hljs-comment">// backgroundColor: barColor,</span><br>          actions: &lt;Widget&gt;[<br>            <span class="hljs-keyword">new</span> IconButton(<br>                icon: <span class="hljs-keyword">const</span> Icon(Icons.lightbulb_outlined),<br>                onPressed: _switchDarkMode),<br>            <span class="hljs-keyword">new</span> IconButton(icon: <span class="hljs-keyword">const</span> Icon(Icons.list), onPressed: _pushSaved),<br>          ],<br>        ),<br>        body: _buildSuggestions(),<br>      ),<br>    );<br>  &#125;<br></code></pre></td></tr></table></figure><p>然后写这个<code>_switchDarkMode</code>就很轻松简单了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _switchDarkMode() &#123;<br>    setState(() &#123;<br>      <span class="hljs-keyword">if</span> (isDark) &#123;<br>        themeData = <span class="hljs-keyword">new</span> ThemeData.light();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        themeData = <span class="hljs-keyword">new</span> ThemeData.dark();<br>      &#125;<br>      isDark = !isDark;<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><p>改完之后你会发现切换白天/黑夜模式可以了，非常开心。但是当你点进收藏列表，它又报错了。</p><h3 id="修改官方版本的路由代码"><a href="#修改官方版本的路由代码" class="headerlink" title="修改官方版本的路由代码"></a>修改官方版本的路由代码</h3><p>官方的路由这样的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _pushSaved() &#123;<br>  Navigator.of(context).push(<br>    <span class="hljs-keyword">new</span> MaterialPageRoute&lt;<span class="hljs-keyword">void</span>&gt;(<br>      ...                           <br>    )<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>报错也是提示出错是出在这里，那么这里为什么出错呢？这可能就需要去了解一些关于这里的 <strong>of(context)</strong> 的知识了。</p><p>我也是才入门了一天，没有去仔细的了解。查阅了网上资料通俗解释一下就是，当我们在 build 函数中使用 Navigator.of(context) 时，这个 context 其实是通过当前这个widget（在官方示例中就是 RandomWords 这个类）创建出来的 <strong>Element</strong> 对象，然后 of 方法会向上去寻找<strong>祖先结点</strong>。在官方实例中这么写是能找到祖先节点的，那就是在 MyApp 中创建的 MaterialApp ，所以官方示例中不会报错。</p><p>而在我们修改的版本里，在 RandomWords 的 build 函数中我又嵌套了一层 MaterialApp（为了实现主题切换功能），这时候在里面用 of 方法去寻找祖先节点可能寻找到这里就停止了，不再往上寻找了，于是就找不到上一层的路由了，所以在这里报了错。（这一段的原因我自己也没弄太明白，欢迎知道的大神指正我orz）</p><p>要修改其实很简单，当前就有一层 MaterialApp 了，因此没必要往上追溯，<strong>直接使用当前的 Navigator</strong> 即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _pushSaved() &#123;<br>    Navigator.push(context,<br>        <span class="hljs-keyword">new</span> MaterialPageRoute(builder: (BuildContext context) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-built_in">Iterable</span>&lt;ListTile&gt; tiles = _saved.map((WordPair pair) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ListTile(<br>          title: <span class="hljs-keyword">new</span> Text(<br>            pair.asPascalCase,<br>            style: _biggerFont,<br>          ),<br>        );<br>      &#125;);<br><br>      <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;Widget&gt; divided = ListTile.divideTiles(<br>        context: context,<br>        tiles: tiles,<br>      ).toList();<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Scaffold(<br>          appBar: <span class="hljs-keyword">new</span> AppBar(<br>            leading: <span class="hljs-keyword">new</span> IconButton(<br>                icon: <span class="hljs-keyword">const</span> Icon(Icons.chevron_left),<br>                onPressed: () &#123;<br>                  Navigator.pop(context);<br>                &#125;),<br>            title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;我的收藏&#x27;</span>),<br>          ),<br>          body: <span class="hljs-keyword">new</span> ListView(children: divided),<br>      );<br>    &#125;));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统一主题"><a href="#统一主题" class="headerlink" title="统一主题"></a>统一主题</h3><p>还有一点需要注意的就是官方示例中跳转到新页面时是直接返回的一个 Scaffold ，这样 Navigator 会自动创建一个“返回按钮”，但是我们想统一主题的话还是像我一开始所说的需要<strong>创建一个 MaterialApp</strong> ，所以这也需要自己手动添加“返回”按钮及功能了。</p><p>在上面 _pushSaved 方法中的 return 进行修改即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MaterialApp(<br>    theme: themeData,<br>    home: <span class="hljs-keyword">new</span> Scaffold(<br>        appBar: <span class="hljs-keyword">new</span> AppBar(<br>        leading: <span class="hljs-keyword">new</span> IconButton(<br>            icon: <span class="hljs-keyword">const</span> Icon(Icons.chevron_left),<br>            onPressed: () &#123;<br>                Navigator.pop(context);<br>            &#125;),<br>        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;我的收藏&#x27;</span>),<br>        ),<br>        body: <span class="hljs-keyword">new</span> ListView(children: divided),<br>    ),<br>);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，Flutter 还是一个很好用的框架的，至少对我来说是如此。虽然 Dart 的嵌套一直被人诟病，但是 Dart 对于后端人员比较容易上手也算是他的一个优势吧，我个人认为他在快速开发一个应用上表现非常好。当然，这个系列后面的内容我肯定也是会围绕着那个声网的 SDK 去做的，毕竟这才是我的初衷哈哈。</p><p>最后再提供几个十分实用的资源:</p><ul><li><a href="https://api.flutter.dev/index.html">官方API</a></li><li><a href="https://flutter.cn/docs/cookbook">CookBook</a></li><li><a href="https://codelabs.flutter-io.cn/">CodeLabs</a></li><li><a href="https://gallery.flutter.dev/#/">Gallery</a></li><li><a href="https://fonts.google.com/icons?selected=Material+Icons">查看flutter提供的icons</a></li><li><a href="https://github.com/fengerwoo/easy_anim">更好的使用flutter动画的方式</a></li><li><a href="https://github.com/Solido/awesome-flutter">Awesome-Flutter</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近声网办了一个编程挑战赛，用他们的 SDK 来开发应用。我也是对此比较感兴趣就想了解了解，同时做个作品。但是我对于前端的东西 js 一类的比较反感哈哈，不太想去学，于是就看看移动端上有没有什么易于开发的东西。之前也是读过《第一行代码》，学过安卓，但是安卓的更新迭代太快了，以前的安卓项目现在都没法运行起来了，故也不太想捣鼓安卓。&lt;/p&gt;</summary>
    
    
    
    <category term="Flutter" scheme="https://congregalis.github.io/categories/Flutter/"/>
    
    
    <category term="移动开发" scheme="https://congregalis.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="flutter" scheme="https://congregalis.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>从递归到记忆化递归再到dp</title>
    <link href="https://congregalis.github.io/2021/04/21/%E4%BB%8E%E9%80%92%E5%BD%92%E5%88%B0%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%E5%86%8D%E5%88%B0dp/"/>
    <id>https://congregalis.github.io/2021/04/21/%E4%BB%8E%E9%80%92%E5%BD%92%E5%88%B0%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%E5%86%8D%E5%88%B0dp/</id>
    <published>2021-04-21T06:23:43.000Z</published>
    <updated>2021-04-29T15:42:09.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天做了一道题，觉得这个思想还挺有价值的，故写下这篇文记录一下。</p><p>题目是<a href="https://leetcode-cn.com/problems/decode-ways/">LC91</a>，是一道很基础的题。</p><p><img src="/img/20210421dp/question.jpg"></p><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>看到这个题，一下能想到的方法就是递归搜索了。<br>因为这个题解码时只有两种情况，在某个状态截取1个字符或截取两个字符，所以递归做起来也不会很复杂。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归解法（超时）</span><br>        <span class="hljs-keyword">return</span> dfs(s.toCharArray(), s.length(), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-comment">// 找到了一条解码方式</span><br>        <span class="hljs-keyword">if</span> (index &gt;= len) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>        <span class="hljs-comment">// &#x27;0&#x27;没有解码方式（10或20可以在下面截取2个字符时截取得到，所以不用担心这样漏解）</span><br>        <span class="hljs-keyword">if</span> (chars[index] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 截取1个字符时</span><br>        <span class="hljs-keyword">int</span> res = dfs(chars, len, index + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 截取2个字符时</span><br>        <span class="hljs-keyword">if</span> (index &lt; len - <span class="hljs-number">1</span> &amp;&amp; ((chars[index] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (chars[index+<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>))<br>            res += dfs(chars, len, index + <span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这个方法毫无疑问会超时，但是这无疑是我们往后优化所必不可少的第一步。</p><h3 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h3><p>抓耳挠腮了半天，甚至动笔模拟了很久，会发现这个递归的方法存在很多不必要的重复计算。<br>在计算一个字符串编码方式时，这个普通的递归方法会多次重复计算它的子编码方式（即它的子字符串的编码方式）</p><p>如果不懂的话，看一下代码比较容易理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// 记忆化递归</span><br><br>        <span class="hljs-comment">// 使用一个数组来存储计算结果就行了</span><br>        <span class="hljs-comment">// 只需要存储s中从index开始到最后有多少种解码方式就行了</span><br>        <span class="hljs-keyword">int</span>[] record = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length()];<br>        Arrays.fill(record, -<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> dfs(s.toCharArray(), s.length(), <span class="hljs-number">0</span>, record);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span>[] record)</span> </span>&#123;<br>        <span class="hljs-comment">// 找到了一条解码方式</span><br>        <span class="hljs-keyword">if</span> (index &gt;= len) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>        <span class="hljs-comment">// &#x27;0&#x27;没有解码方式（10或20可以在下面截取2个字符时截取得到，所以不用担心这样漏解）</span><br>        <span class="hljs-keyword">if</span> (chars[index] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果已经计算过了，直接返回计算结果</span><br>        <span class="hljs-keyword">if</span> (record[index] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> record[index];<br><br>        <span class="hljs-comment">// 截取1个字符时</span><br>        <span class="hljs-keyword">int</span> res = dfs(chars, len, index + <span class="hljs-number">1</span>, record);<br>        <span class="hljs-comment">// 截取2个字符时</span><br>        <span class="hljs-keyword">if</span> (index &lt; len - <span class="hljs-number">1</span> &amp;&amp; ((chars[index] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (chars[index+<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>))<br>            res += dfs(chars, len, index + <span class="hljs-number">2</span>, record);<br>        <br>        record[index] = res; <span class="hljs-comment">// 记录下index下有多少种解码方式</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，其实已经优化的很好了，但是还可以使用动态规划解决。</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>DP的方法其实就是把记忆化递归的方式写成迭代的方式。<br>在记忆化递归中，记录数组record是在s中从后往前记录的，当然DP也可以从后往前写，但是从前往后比较符合我们人类的思维，所以我这里从前往后使用迭代的方式来做。</p><p>如果是一步步做下来的，其实可以很轻松地发现状态转移方程。<br><code>dp[i] = dp[i-1] + dp[i-2]</code><br>只是在处理边界条件和判断进入哪种状态时需要稍微注意一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// dp解法</span><br>        <span class="hljs-comment">// 比s长度大1，是为了添加一个哨兵</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length() + <span class="hljs-number">1</span>];<br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 哨兵，防止第一个字符就是&#x27;0&#x27;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-comment">// 截取一个字符时</span><br>            <span class="hljs-comment">// 只要不是&#x27;0&#x27;都可以接受</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;0&#x27;</span>)<br>                dp[i] = dp[i-<span class="hljs-number">1</span>];<br><br>            <span class="hljs-comment">// 截取两个字符时</span><br>            <span class="hljs-comment">// 除了要小于26以外，使用我这种方法判断的话还要避免第一位是0</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span> &amp;&amp; s.charAt(i-<span class="hljs-number">2</span>) != <span class="hljs-string">&#x27;0&#x27;</span> <br>                &amp;&amp; ((s.charAt(i-<span class="hljs-number">2</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s.charAt(i-<span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>))<br>                dp[i] += dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是觉得dp的方式更加优雅简洁呢。</p><p>其实还有更加节省空间的方式，就是把dp数组换成只使用两个变量。因为这里在计算第i个位置的dp时只用到了i-1与i-2两个位置，我这里就不再写下去啦。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实DP和记忆化递归是一样的，只是采用了不同的写法。但是从头直接用动态规划的思想做的话可能会有点困难，所以想不出解法的时候不妨先从最普通的递归开始，一步一步进行优化。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>有什么相关题目值得一做的我会补充在这里。</p><ul><li><a href="https://leetcode-cn.com/problems/combination-sum-iv/">LC337.组合总和 Ⅳ</a></li><li><a href="https://leetcode-cn.com/problems/frog-jump/">LC403.青蛙过河</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;今天做了一道题，觉得这个思想还挺有价值的，故写下这篇文记录一下。&lt;/p&gt;
&lt;p&gt;题目是&lt;a href=&quot;https://leetcode-cn.com/problems/decode-ways/&quot;&gt;LC91&lt;/a&gt;，是一道很基础的题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/20210421dp/question.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;解&quot;&gt;&lt;a href=&quot;#解&quot; class=&quot;headerlink&quot; title=&quot;解&quot;&gt;&lt;/a&gt;解&lt;/h2&gt;&lt;h3 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h3&gt;&lt;p&gt;看到这个题，一下能想到的方法就是递归搜索了。&lt;br&gt;因为这个题解码时只有两种情况，在某个状态截取1个字符或截取两个字符，所以递归做起来也不会很复杂。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://congregalis.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="https://congregalis.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>随机考察知识点 - 即开即用的web服务</title>
    <link href="https://congregalis.github.io/2021/04/21/%E9%9A%8F%E6%9C%BA%E8%80%83%E5%AF%9F%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%8D%B3%E5%BC%80%E5%8D%B3%E7%94%A8%E7%9A%84web%E6%9C%8D%E5%8A%A1/"/>
    <id>https://congregalis.github.io/2021/04/21/%E9%9A%8F%E6%9C%BA%E8%80%83%E5%AF%9F%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%8D%B3%E5%BC%80%E5%8D%B3%E7%94%A8%E7%9A%84web%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-04-20T18:44:44.000Z</published>
    <updated>2021-04-29T15:41:39.638Z</updated>
    
    <content type="html"><![CDATA[<p>这是我在考研前突发奇想做的一个用来随机检测自己某个知识点掌握得如何的小工具。当时正好在学django，就用django+vue做了这么一个小玩意，那么就以这篇文章记录一下这个事吧。</p><span id="more"></span><p>github地址：<a href="https://github.com/Congregalis/question_bank">https://github.com/Congregalis/question_bank</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为了模拟初高中时，和同学互相提问抽查知识点的场景，我写了这个小工具。它的功能就是充当你的同学，随机的考察你一些问题，帮助你在考试中取得更好成绩！</p><p>我比较追求简洁使用，就参考vue官方的文档简单写了一个页面，Demo大致如下图</p><p><img src="/img/question_bank/question_bank_vue.png"><br><img src="/img/question_bank/answer.png"></p><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><p>本来我考研之前部署在之前买的阿里云服务器上可以直接访问。但是现在过期了没钱续费，想看demo的话可以clone到本地部署运行。</p><p>首先自己创建一个python虚拟环境，然后安装requirement.txt下的包</p><p><code>pip install -r requirement.txt</code></p><p>然后对数据库进行一次初始化</p><p><code>python manage.py makemigrations</code></p><p><code>python manage.py migrate --run-syncdb</code></p><p>然后创建一个用户，否则没有权限新建问题（除了下面通过运行python的方法你也可以操作sqlite数据库新建用户）</p><p><code>python manage.py shell</code> </p><p>打开python命令行，输入以下命令来创建一个admin用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.models <span class="hljs-keyword">import</span> User<br>User.objects.create_superuser(username=<span class="hljs-string">&#x27;admin&#x27;</span>, password=<span class="hljs-string">&#x27;123&#x27;</span>, email=<span class="hljs-string">&#x27;no@no,com&#x27;</span>)<br>exit()<br></code></pre></td></tr></table></figure><p>然后开启后台服务</p><p><code>python manage.py runserver</code> </p><p>默认开启在8000端口，当然也可以自己指定端口，此时访问 <a href="localhost:8000">localhost:8000</a> 即可浏览后台管理的api文档（可直接操作），使用刚刚新建的用户登录就可以新建问题了</p><p><img src="/img/question_bank/post_q.png"><br><img src="/img/question_bank/post_res.png"><br><img src="/img/question_bank/categories.png"></p><p>前端页面由vue编写，直接打开项目根目录下的html文件即可浏览（当然，数据库里需要有你新建的问题）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是我在考研前突发奇想做的一个用来随机检测自己某个知识点掌握得如何的小工具。当时正好在学django，就用django+vue做了这么一个小玩意，那么就以这篇文章记录一下这个事吧。&lt;/p&gt;</summary>
    
    
    
    <category term="小项目" scheme="https://congregalis.github.io/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="django" scheme="https://congregalis.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://congregalis.github.io/2021/04/19/hello-world/"/>
    <id>https://congregalis.github.io/2021/04/19/hello-world/</id>
    <published>2021-04-19T11:45:10.063Z</published>
    <updated>2021-04-19T11:45:10.063Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
